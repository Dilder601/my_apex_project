 CREATE TABLE "ADM_CODES" 
   (	"CODE_ID" NUMBER(10,0) NOT NULL ENABLE, 
	"PARENT" NUMBER(10,0), 
	"CODE_KEY" VARCHAR2(30) NOT NULL ENABLE, 
	"CODE_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"CODE_GROUP" VARCHAR2(50), 
	"DESCRIPTION" VARCHAR2(200), 
	"ACCESS_ROLES" VARCHAR2(100), 
	"ACCESS_INST_ID" NUMBER, 
	"SORT_ORDER" NUMBER(10,0), 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	 PRIMARY KEY ("CODE_ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "ADM_CODES_SQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 37 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/

  CREATE OR REPLACE EDITIONABLE TRIGGER "ADM_CODES_BR_TRI" 
BEFORE UPDATE OR INSERT OR DELETE
ON ADM_CODES
FOR EACH ROW
BEGIN

	IF INSERTING THEN
		IF(:NEW.CODE_ID IS NULL) THEN
			:NEW.CODE_ID := ADM_CODES_SQ.NEXTVAL;
		END IF;
		-- :NEW.CREATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		--:NEW.CREATED_AT := SYSDATE;
	ELSIF UPDATING THEN
		-- :NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;

END;
/

CREATE TABLE "ADM_CODE_ELEMENTS" 
   (	"ELEMENT_ID" NUMBER(10,0) NOT NULL ENABLE, 
	"CODE_ID" NUMBER(10,0) NOT NULL ENABLE, 
	"CODE_KEY" VARCHAR2(30) NOT NULL ENABLE, 
	"ELEMENT_KEY" VARCHAR2(30) NOT NULL ENABLE, 
	"ELEMENT_NAME" VARCHAR2(300) NOT NULL ENABLE, 
	"DISPLAY_VALUE" VARCHAR2(30), 
	"DETAIL_VALUE" VARCHAR2(4000), 
	"DESCRIPTION" VARCHAR2(1000), 
	"PARENT" NUMBER(10,0), 
	"LVL" NUMBER(3,0), 
	"SORT_ORDER" NUMBER(10,0), 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	 PRIMARY KEY ("ELEMENT_ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "ADM_CODE_ELEMENTS_SQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 68 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/

CREATE OR REPLACE EDITIONABLE TRIGGER "ADM_CODE_ELEMENTS_BR_TRI" 
BEFORE UPDATE OR INSERT OR DELETE
ON ADM_CODE_ELEMENTS
FOR EACH ROW
BEGIN

	IF INSERTING THEN
		IF(:NEW.ELEMENT_ID IS NULL) THEN
			:NEW.ELEMENT_ID := ADM_CODE_ELEMENTS_SQ.NEXTVAL;
		END IF;
		-- :NEW.CREATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		--:NEW.CREATED_AT := SYSDATE;
	ELSIF UPDATING THEN
		-- :NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;

END;
/

CREATE TABLE "ADM_INSTITUTE" 
   (	"INST_ID" NUMBER, 
	"INST_NAME" VARCHAR2(100), 
	"INST_ADDRESS" VARCHAR2(1000), 
	"INST_IMAGE" BLOB, 
	"INST_EMAIL" VARCHAR2(100), 
	"INST_PHONE" VARCHAR2(100), 
	"SORT_ORDER" NUMBER(10,0), 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	 PRIMARY KEY ("INST_ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "ADM_INSTITUTE_SQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/


  CREATE OR REPLACE EDITIONABLE TRIGGER "ADM_INSTITUTE_BR_TRI" 
    BEFORE INSERT 
    ON ADM_INSTITUTE 
    FOR EACH ROW
BEGIN
    IF INSERTING THEN
        IF (:NEW.INST_ID) IS NULL THEN
            :NEW.INST_ID :=  ADM_INSTITUTE_SQ.NEXTVAL;
        END IF;
    ELSIF UPDATING THEN
		--:NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END;
/

 CREATE TABLE "BL_USER_ROLE" 
   (	"ID" NUMBER, 
	"ROLE_ID" NUMBER, 
	"USERNAME" VARCHAR2(100), 
	"STATUS" VARCHAR2(10), 
	"CREATED_BY" VARCHAR2(100), 
	"CREATED_AT" TIMESTAMP (8), 
	"UPDATED_BY" VARCHAR2(100), 
	"UPDATED_AT" TIMESTAMP (8), 
	 PRIMARY KEY ("ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "BL_USER_ROLE_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1002 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/

  CREATE OR REPLACE EDITIONABLE TRIGGER "BL_USER_ROLE_TRG" 
BEFORE UPDATE OR INSERT OR DELETE
ON BL_USER_ROLE
FOR EACH ROW
BEGIN
	IF INSERTING THEN
		IF(:NEW.ID IS NULL) THEN
			:NEW.ID := BL_USER_ROLE_SEQ.NEXTVAL;
		END IF;
		 :NEW.CREATED_BY := NVL(v('APP_USER'),1);
		 :NEW.CREATED_AT := SYSDATE;
	ELSIF UPDATING THEN
		 :NEW.UPDATED_BY := NVL(v('APP_USER'),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END;
/


CREATE TABLE "BL_USER_ROLE_DTL" 
   (	"ID" NUMBER, 
	"ROLE_ID" NUMBER, 
	"PAGE_ID" NUMBER, 
	"STATUS" VARCHAR2(10), 
	"CREATED_BY" VARCHAR2(100), 
	"CREATED_AT" TIMESTAMP (8), 
	"UPDATED_BY" VARCHAR2(100), 
	"UPDATED_AT" TIMESTAMP (8), 
	 PRIMARY KEY ("ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "BL_USER_ROLE_DTL_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1018 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/

  CREATE OR REPLACE EDITIONABLE TRIGGER "BL_USER_ROLE_DTL_TRG" 
BEFORE UPDATE OR INSERT OR DELETE
ON BL_USER_ROLE_DTL
FOR EACH ROW
BEGIN
	IF INSERTING THEN
		IF(:NEW.ID IS NULL) THEN
			:NEW.ID := BL_USER_ROLE_DTL_SEQ.NEXTVAL;
		END IF;
		 :NEW.CREATED_BY := NVL(v('APP_USER'),1);
		 :NEW.CREATED_AT := SYSDATE;
	ELSIF UPDATING THEN
		 :NEW.UPDATED_BY := NVL(v('APP_USER'),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END;
/


 CREATE TABLE "BL_USER_ROLE_DTL_OTHERS" 
   (	"ID" NUMBER, 
	"ROLE_ID" NUMBER, 
	"PAGE_ID" NUMBER, 
	"STATUS" VARCHAR2(10), 
	"CREATED_BY" VARCHAR2(100), 
	"CREATED_AT" TIMESTAMP (8), 
	"UPDATED_BY" VARCHAR2(100), 
	"UPDATED_AT" TIMESTAMP (8), 
	"USERNAME" VARCHAR2(100) NOT NULL ENABLE, 
	 PRIMARY KEY ("ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "BL_USER_ROLE_DTL_OTHERS_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1000 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/

  CREATE OR REPLACE EDITIONABLE TRIGGER "BL_USER_ROLE_DTL_OTHERS_TRG" 
BEFORE UPDATE OR INSERT OR DELETE
ON BL_USER_ROLE_DTL_OTHERS
FOR EACH ROW
BEGIN
	IF INSERTING THEN
		IF(:NEW.ID IS NULL) THEN
			:NEW.ID := BL_USER_ROLE_DTL_OTHERS_SEQ.NEXTVAL;
		END IF;
		 :NEW.CREATED_BY := NVL(v('APP_USER'),1);
		 :NEW.CREATED_AT := SYSDATE;
	ELSIF UPDATING THEN
		 :NEW.UPDATED_BY := NVL(v('APP_USER'),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END;
/


 CREATE TABLE "BL_USER_ROLE_MST" 
   (	"ID" NUMBER, 
	"ROLE_NAME" VARCHAR2(100), 
	"STATUS" VARCHAR2(10), 
	"CREATED_BY" VARCHAR2(100), 
	"CREATED_AT" TIMESTAMP (8), 
	"UPDATED_BY" VARCHAR2(100), 
	"UPDATED_AT" TIMESTAMP (8), 
	 PRIMARY KEY ("ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "BL_USER_ROLE_MST_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1003 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/

  CREATE OR REPLACE EDITIONABLE TRIGGER "BL_USER_ROLE_MST_TRG" 
BEFORE UPDATE OR INSERT OR DELETE
ON  BL_USER_ROLE_MST
FOR EACH ROW
BEGIN
	IF INSERTING THEN
		IF(:NEW.ID IS NULL) THEN
			:NEW.ID := BL_USER_ROLE_MST_SEQ.NEXTVAL;
		END IF;
		 :NEW.CREATED_BY := NVL(v('APP_USER'),1);
		 :NEW.CREATED_AT := SYSDATE;
	ELSIF UPDATING THEN
		 :NEW.UPDATED_BY := NVL(v('APP_USER'),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END;
/


 CREATE TABLE "EMP_USERS" 
   (	"EMP_ID" NUMBER, 
	"EMP_CODE" VARCHAR2(30), 
	"ID_CARD_NO" VARCHAR2(30), 
	"EMP_NAME" VARCHAR2(1000), 
	"DOB" DATE, 
	"FATHER_NAME" VARCHAR2(1000), 
	"MOTHER_NAME" VARCHAR2(1000), 
	"MARITAL_STATUS" NUMBER, 
	"SPOUSE_NAME" VARCHAR2(500), 
	"MARRIAGE_DATE" DATE, 
	"PASSPORT" VARCHAR2(100), 
	"DRIVING_LIC_NO" VARCHAR2(100), 
	"DRIVING_LIC_TYPE" NUMBER, 
	"BIRTH_REG_NO" VARCHAR2(50), 
	"NID" VARCHAR2(1000), 
	"MOBILE_NO" VARCHAR2(1000), 
	"MOBILE_NO_OFFICE" VARCHAR2(1000), 
	"EMAIL_ID" VARCHAR2(1000), 
	"GENDER" NUMBER, 
	"RELIGION" NUMBER, 
	"BLOOD_GRP" NUMBER, 
	"USER_STATUS" NUMBER DEFAULT 1, 
	"USER_IMAGE" BLOB, 
	"PRE_HOLDING_NO" VARCHAR2(50), 
	"PRE_ROAD" VARCHAR2(200), 
	"PRE_VILLAGE" VARCHAR2(500), 
	"PRE_POLICE_STN" VARCHAR2(200), 
	"PRE_POST_OFFICE" VARCHAR2(200), 
	"PRE_POST_CODE" VARCHAR2(200), 
	"PRE_DISTICT" VARCHAR2(200), 
	"PER_HOLDING_NO" VARCHAR2(50), 
	"PER_ROAD" VARCHAR2(200), 
	"PER_VILLAGE" VARCHAR2(500), 
	"PER_POLICE_STN" VARCHAR2(200), 
	"PER_POST_OFFICE" VARCHAR2(200), 
	"PER_POST_CODE" VARCHAR2(200), 
	"PER_DISTICT" VARCHAR2(200), 
	"MIMETYPE" VARCHAR2(255), 
	"FILENAME" VARCHAR2(400), 
	"IMAGE_LAST_UPDATE" TIMESTAMP (6), 
	"INST_ID" NUMBER, 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	"NICKNAME" VARCHAR2(200), 
	"PWD" VARCHAR2(50) DEFAULT '123456', 
	"ASSIGN_BLOCK" VARCHAR2(10), 
	 PRIMARY KEY ("EMP_ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "EMP_USERS_SQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 7 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/


  CREATE OR REPLACE EDITIONABLE TRIGGER "EMP_USERS_BR_TRI" 
    BEFORE INSERT 
    ON EMP_USERS 
    FOR EACH ROW
BEGIN
    IF INSERTING THEN
        IF (:NEW.EMP_ID) IS NULL THEN
            :NEW.EMP_ID :=  EMP_USERS_SQ.NEXTVAL;
        END IF;

    INSERT INTO BL_USER_ROLE (ID, ROLE_ID, USERNAME, STATUS)
                      VALUES (BL_USER_ROLE_SEQ.NEXTVAL,:NEW.USER_STATUS, :NEW.EMP_CODE, 1); 

    ELSIF UPDATING THEN
		--:NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END;
/

  CREATE TABLE "TEST_CLOB" 
   (	
    "COL1" CLOB, 
	"COL2" NUMBER
   ) ;
/

 CREATE TABLE "VV_ACCOUNTS" 
   (	"ACCOUNT_NO" NUMBER, 
	"ACCOUNT_NAME" VARCHAR2(100), 
	"ACCOUNT_TYPE" NUMBER, 
	"DEBT_AMOUNT" NUMBER, 
	"MEMBER_ID" NUMBER, 
	"INST_ID" NUMBER, 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	 PRIMARY KEY ("ACCOUNT_NO")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "VV_ACCOUNTS_SQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/



  CREATE OR REPLACE EDITIONABLE TRIGGER "VV_ACCOUNTS_BR_TRI" 
    BEFORE INSERT 
    ON VV_ACCOUNTS 
    FOR EACH ROW
BEGIN
    IF INSERTING THEN
        IF (:NEW.ACCOUNT_NO) IS NULL THEN
            :NEW.ACCOUNT_NO :=  VV_ACCOUNTS_SQ.NEXTVAL;
        END IF;
    ELSIF UPDATING THEN
		--:NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END;
/

CREATE TABLE "VV_APPLY_LOAN" 
   (	"APPLY_ID" NUMBER, 
	"APPLY_DATE" DATE, 
	"LOAN_AMT" NUMBER, 
	"TOTAL_AMT_WITH_INTEREST" NUMBER, 
	"PER_DAY_COLL" NUMBER, 
	"MEMBER_ID" NUMBER, 
	"INST_ID" NUMBER, 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	"REMAIN_LOAN_BALANCE" NUMBER, 
    "LOAN_ID"   NUMBER, 
	"CLOSING_DATE" DATE,
	 PRIMARY KEY ("APPLY_ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "VV_APPLY_LOAN_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 8 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/

CREATE OR REPLACE EDITIONABLE TRIGGER "VV_APPLY_LOAN_BR_TRI" 
BEFORE UPDATE OR INSERT OR DELETE
ON VV_APPLY_LOAN
FOR EACH ROW
BEGIN

	IF INSERTING THEN
		IF(:NEW.APPLY_ID IS NULL) THEN
			:NEW.APPLY_ID := VV_APPLY_LOAN_SEQ.NEXTVAL;
		END IF;
		 --:NEW.CREATED_BY := NVL(v('APP_USER'),1);
		 :NEW.CREATED_AT := SYSDATE;

         :NEW.REMAIN_LOAN_BALANCE := :NEW.TOTAL_AMT_WITH_INTEREST;

	ELSIF UPDATING THEN
		-- :NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;

		DECLARE
            vDIFF_BAL_NEW_HIGH NUMBER:= 0;
            vDIFF_BAL_OLD_HIGH NUMBER:= 0;
		BEGIN
            IF :NEW.TOTAL_AMT_WITH_INTEREST <> :OLD.TOTAL_AMT_WITH_INTEREST THEN
            
                IF :NEW.TOTAL_AMT_WITH_INTEREST > :OLD.TOTAL_AMT_WITH_INTEREST THEN
                
                    vDIFF_BAL_NEW_HIGH := NVL(:NEW.TOTAL_AMT_WITH_INTEREST,0) - NVL(:OLD.TOTAL_AMT_WITH_INTEREST,0); --10000
                    
                    :NEW.REMAIN_LOAN_BALANCE := :OLD.REMAIN_LOAN_BALANCE + vDIFF_BAL_NEW_HIGH;
                ELSE 
                    vDIFF_BAL_OLD_HIGH := NVL(:OLD.TOTAL_AMT_WITH_INTEREST,0) - NVL(:NEW.TOTAL_AMT_WITH_INTEREST,0);
                    
                    :NEW.REMAIN_LOAN_BALANCE :=  :OLD.REMAIN_LOAN_BALANCE - vDIFF_BAL_OLD_HIGH;
                END IF;
                
            END IF;
		END;
	
		
	END IF;

END "VV_APPLY_LOAN_BR_TRI";
/


 CREATE TABLE "VV_CLOSING_SCHEDULE" 
   (	"SCHEDULE_ID" NUMBER, 
	"SCHEDULE_DATE" DATE, 
	"SCHEDULE_FOR_YEAR" NUMBER, 
	"SCHEDULE_FOR_MONTH" NUMBER, 
	"START_DATE" DATE, 
	"END_DATE" DATE, 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	 PRIMARY KEY ("SCHEDULE_ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "VV_CLOSING_SCHEDULE_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 5 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/


  CREATE OR REPLACE EDITIONABLE TRIGGER "VV_CLOSING_SCHEDULE_BR_TRI" 
BEFORE UPDATE OR INSERT OR DELETE
ON VV_CLOSING_SCHEDULE
FOR EACH ROW
BEGIN

	IF INSERTING THEN
		IF(:NEW.SCHEDULE_ID IS NULL) THEN
			:NEW.SCHEDULE_ID := VV_CLOSING_SCHEDULE_SEQ.NEXTVAL;
		END IF;
		 --:NEW.CREATED_BY := NVL(v('APP_USER'),1);
		 :NEW.CREATED_AT := SYSDATE;
	ELSIF UPDATING THEN
		-- :NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;

END;
/

 CREATE TABLE "VV_COLL_WITHDRAW" 
   (	"WITHDRAW_ID" NUMBER, 
	"WITHDRAW_DATE" DATE, 
	"MEMBER_ID" NUMBER, 
	"WITHDRAW_AMT" NUMBER, 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	"SCHEDULE_ID" NUMBER, 
	"IS_CLOSING" VARCHAR2(1) DEFAULT 'N', 
	"REMARKS" VARCHAR2(500), 
	 PRIMARY KEY ("WITHDRAW_ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "VV_COLL_WITHDRAW_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 25 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/

create or replace TRIGGER "VV_COLL_WITHDRAW_BR_TRI" 
BEFORE UPDATE OR INSERT OR DELETE
ON VV_COLL_WITHDRAW
FOR EACH ROW
DECLARE
    vCOLL_EXIST NUMBER;
BEGIN

	IF INSERTING THEN
		IF(:NEW.WITHDRAW_ID IS NULL) THEN
			:NEW.WITHDRAW_ID := VV_COLL_WITHDRAW_SEQ.NEXTVAL;
		END IF; 
		 :NEW.CREATED_AT := SYSDATE;

            BEGIN

                UPDATE VV_MEMBER 
                   SET COLLECTED_AMOUNT = (NVL(COLLECTED_AMOUNT,0) - NVL(:NEW.WITHDRAW_AMT,0)) 
                 WHERE MEMBER_ID = :NEW.MEMBER_ID;

             END;


       SELECT COLLECTED_AMOUNT INTO vCOLL_EXIST FROM VV_MEMBER WHERE MEMBER_ID = :NEW.MEMBER_ID;
       

        IF vCOLL_EXIST = 0 THEN
                UPDATE VV_MEMBER SET STATUS = 0 WHERE MEMBER_ID = :NEW.MEMBER_ID;
        END IF;

		
	ELSIF UPDATING THEN
		-- :NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;

END VV_COLL_WITHDRAW_BR_TRI;
/

CREATE TABLE "VV_DAILY_COLLECTION" 
   (	"COLLECTION_ID" NUMBER, 
	"COLLECTION_DATE" DATE, 
	"EMP_ID" NUMBER, 
	"COLLECTION_AMOUT" NUMBER, 
	"MEMBER_ID" NUMBER, 
	"DEPOSIT_MONEY" NUMBER, 
	"DEBT_AMOUNT" NUMBER, 
	"DEBT_REMAIN" NUMBER, 
	"INST_ID" NUMBER, 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	"COLLECTION_MODE" NUMBER, 
	"IS_POST" VARCHAR2(1) DEFAULT 'N', 
	"SCHEDULE_ID" NUMBER, 
	"IS_CLOSING" VARCHAR2(1) DEFAULT 'N', 
	"TRANSACTION_CODE" VARCHAR2(100), 
	"BANK_ID" NUMBER, 
	"BANK_ACCOUNT_NO" NUMBER, 
	 PRIMARY KEY ("COLLECTION_ID")
  USING INDEX  ENABLE
   ) ;
/

  CREATE OR REPLACE TRIGGER MEMBER_DAILY_COLL_TOTAL_TRI
    AFTER INSERT OR UPDATE 
    ON VV_DAILY_COLLECTION
    FOR EACH ROW
DECLARE
    vCNT            NUMBER;
    vCOLLECTION_AMT NUMBER;
BEGIN

       SELECT COUNT(*)  INTO vCNT
        FROM VV_MEMBER
        WHERE MEMBER_ID = :NEW.MEMBER_ID;


    IF INSERTING THEN 

        IF vCNT > 0 THEN 

            UPDATE VV_MEMBER 
            SET COLLECTED_AMOUNT = NVL(COLLECTED_AMOUNT,0) + NVL(:NEW.COLLECTION_AMOUT,0)
            WHERE MEMBER_ID = :NEW.MEMBER_ID;

        END IF;

   END IF;

END MEMBER_DAILY_COLL_TOTAL_TRI;
/

   CREATE SEQUENCE  "VV_DAILY_COLL_SQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 68 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/

ALTER TRIGGER "MEMBER_DAILY_COLL_TOTAL_TRI" ENABLE;

  create or replace TRIGGER "VV_DAILY_COLL_BR_TRI" 
    BEFORE INSERT 
    ON VV_DAILY_COLLECTION 
    FOR EACH ROW
DECLARE
    vROLE_ID NUMBER;
BEGIN
    IF INSERTING THEN
        IF (:NEW.COLLECTION_ID) IS NULL THEN
            :NEW.COLLECTION_ID :=  VV_DAILY_COLL_SQ.NEXTVAL;
        END IF;
        --  FOR I IN (SELECT * FROM VV_CLOSING_SCHEDULE) LOOP
        --      UPDATE VV_DAILY_COLLECTION SET SCHEDULE_ID  = I.SCHEDULE_ID WHERE :NEW.COLLECTION_DATE BETWEEN I.START_DATE AND I.END_DATE;
        --  END LOOP;

        -- UPDATING IS_POST = 'Y' IF COLLECTION USER IS ADMIN

        BEGIN

            --SELECT  A.USER_STATUS INTO vROLE_ID FROM EMP_USERS A JOIN VV_DAILY_COLLECTION B ON B.CREATED_BY = A.CREATED_BY WHERE COLLECTION_ID =:NEW.COLLECTION_ID;

            SELECT DFN_GET_ROLE_ID(v('APP_USER')) INTO vROLE_ID FROM DUAL;

            IF vROLE_ID = 36 THEN 
                :NEW.IS_POST := 'S';
            ELSE 
                :NEW.IS_POST := 'N';
            END IF;


         EXCEPTION WHEN OTHERS 
            THEN NULL;
         END;


    ELSIF UPDATING THEN
		--:NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END;
/

 CREATE TABLE "VV_DAILY_LOAN_COLL" 
   (	"LOAN_ID" NUMBER, 
	"LOAN_DATE" DATE, 
	"EMP_ID" NUMBER, 
	"COLLECTION_MODE" NUMBER, 
	"LOAN_AMOUT" NUMBER, 
	"MEMBER_ID" NUMBER, 
	"INST_ID" NUMBER, 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	"IS_POST" VARCHAR2(1) DEFAULT 'N', 
	"SCHEDULE_ID" NUMBER, 
	"IS_CLOSING" VARCHAR2(1) DEFAULT 'N', 
	"APPLY_ID" NUMBER, 
	 PRIMARY KEY ("LOAN_ID")
  USING INDEX  ENABLE
   ) ;
/


create or replace TRIGGER "VV_DAILY_LOAN_COLL_AR_TRI"
AFTER UPDATE OR INSERT OR DELETE
ON VV_DAILY_LOAN_COLL
FOR EACH ROW
DECLARE 
    vREMAIN_BAL NUMBER :=0;
BEGIN

	IF INSERTING THEN
		UPDATE VV_APPLY_LOAN
           SET REMAIN_LOAN_BALANCE =  REMAIN_LOAN_BALANCE - :NEW.LOAN_AMOUT
        WHERE  APPLY_ID = :NEW.APPLY_ID
         AND STATUS = 1;

        SELECT REMAIN_LOAN_BALANCE INTO vREMAIN_BAL  FROM VV_APPLY_LOAN WHERE APPLY_ID = :NEW.APPLY_ID AND STATUS = 1;

         IF NVL(vREMAIN_BAL,0) = 0 THEN 
            UPDATE VV_APPLY_LOAN 
               SET STATUS = 0 
             WHERE APPLY_ID = :NEW.APPLY_ID AND STATUS = 1;
         END IF;

    ELSIF UPDATING THEN

            UPDATE VV_APPLY_LOAN
               SET REMAIN_LOAN_BALANCE =
                       NVL (REMAIN_LOAN_BALANCE, 0) + (NVL (:NEW.LOAN_AMOUT, 0) - NVL (:OLD.LOAN_AMOUT, 0))
             WHERE APPLY_ID = :NEW.APPLY_ID
               AND STATUS = 1;
		 
	ELSIF DELETING THEN
       UPDATE VV_APPLY_LOAN
           SET REMAIN_LOAN_BALANCE =  NVL(REMAIN_LOAN_BALANCE,0) + NVL(:OLD.LOAN_AMOUT,0)
        WHERE  APPLY_ID = :NEW.APPLY_ID
         AND STATUS = 1;

	END IF;

END VV_DAILY_LOAN_COLL_AR_TRI;
/

   CREATE SEQUENCE  "VV_DAILY_LOAN_COLL_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 37 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/



create or replace TRIGGER "VV_DAILY_LOAN_COLL_BR_TRI"
BEFORE UPDATE OR INSERT OR DELETE
ON VV_DAILY_LOAN_COLL
FOR EACH ROW
DECLARE
    vROLE_ID NUMBER;
BEGIN

	IF INSERTING THEN
		IF(:NEW.LOAN_ID IS NULL) THEN
			:NEW.LOAN_ID := VV_DAILY_LOAN_COLL_SEQ.NEXTVAL;
		END IF;
		 --:NEW.CREATED_BY := NVL(v('APP_USER'),1);
		 :NEW.CREATED_AT := SYSDATE;

         BEGIN

            --SELECT  A.USER_STATUS INTO vROLE_ID FROM EMP_USERS A JOIN VV_DAILY_LOAN_COLL B ON B.CREATED_BY = A.CREATED_BY WHERE LOAN_ID =:NEW.LOAN_ID;

            SELECT DFN_GET_ROLE_ID(v('APP_USER')) INTO vROLE_ID FROM DUAL;

            IF vROLE_ID = 36 THEN 
                :NEW.IS_POST := 'S';
            ELSE 
                :NEW.IS_POST := 'N';
            END IF;


         EXCEPTION WHEN OTHERS 
            THEN NULL;
         END;
        
         
	ELSIF UPDATING THEN
		-- :NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;

    ELSIF DELETING THEN
        --  UPDATE VV_APPLY_LOAN
        --    SET REMAIN_LOAN_BALANCE =  NVL(REMAIN_LOAN_BALANCE,0)  + NVL(:OLD.LOAN_AMOUT,0)
        -- WHERE MEMBER_ID = :NEW.MEMBER_ID;
        NULL;
	END IF;

END;
/

 CREATE TABLE "VV_MEMBER" 
   (	"MEMBER_ID" NUMBER, 
	"MEMBER_NAME" VARCHAR2(100), 
	"ACCOUNT_NO" NUMBER, 
	"NO_OF_SHARE" NUMBER, 
	"FATHER_NAME" VARCHAR2(100), 
	"MOTHER_NAME" VARCHAR2(100), 
	"EMAIL" VARCHAR2(50), 
	"JOINING_DATE" DATE, 
	"MEMBER_ADDRESS" VARCHAR2(4000), 
	"PERMANENT_ADDRESS" VARCHAR2(4000), 
	"CONTACT_NO" VARCHAR2(20), 
	"CONTACT_NO_ALT" VARCHAR2(20), 
	"NAME_OF_NOMINEE" VARCHAR2(100), 
	"NOMINEE_ADDRESS" VARCHAR2(4000), 
	"RELA_WITH_NOMINEE" VARCHAR2(4000), 
	"NOMINEE_CONTACT_NO" VARCHAR2(4000), 
	"INST_ID" NUMBER, 
	"STATUS" VARCHAR2(10) DEFAULT '1' NOT NULL ENABLE, 
	"CREATED_BY" NUMBER(10,0) NOT NULL ENABLE, 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE NOT NULL ENABLE, 
	"UPDATED_BY" NUMBER(10,0), 
	"UPDATED_AT" TIMESTAMP (6), 
	"COLLECTED_AMOUNT" NUMBER DEFAULT 0, 
	"BLOCK_CODE" VARCHAR2(10), 
	"MEMBER_PICTURE" BLOB, 
	"MIMETYPE" VARCHAR2(255), 
	"FILENAME" VARCHAR2(400), 
	"IMAGE_LAST_UPDATE" TIMESTAMP (6), 
	"MEMBER_BLOOD_GROUP" NUMBER, 
	"NOMINEE_BLOOD_GROUP" NUMBER, 
	"NOMINEE_PICTURE" BLOB, 
    "NAME_OF_NOMINEE2" VARCHAR2(100), 
	"NOMINEE_ADDRESS2" VARCHAR2(4000), 
	"RELA_WITH_NOMINEE2" VARCHAR2(4000), 
	"NOMINEE_CONTACT_NO2" VARCHAR2(4000), 
    "NOMINEE_BLOOD_GROUP2" NUMBER, 
	"NOMINEE_PICTURE2" BLOB,
     "NAME_OF_NOMINEE3" VARCHAR2(100), 
	"NOMINEE_ADDRESS3" VARCHAR2(4000), 
	"RELA_WITH_NOMINEE3" VARCHAR2(4000), 
	"NOMINEE_CONTACT_NO3" VARCHAR2(4000), 
    "NOMINEE_BLOOD_GROUP3" NUMBER, 
	"NOMINEE_PICTURE3" BLOB,
	 PRIMARY KEY ("MEMBER_ID")
  USING INDEX  ENABLE
   ) ;
/

   CREATE SEQUENCE  "VV_MEMBER_SQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 9 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
/

  CREATE OR REPLACE EDITIONABLE TRIGGER "VV_MEMBER_BR_TRI" 
    BEFORE INSERT 
    ON VV_MEMBER 
    FOR EACH ROW
BEGIN
    IF INSERTING THEN
        IF (:NEW.MEMBER_ID) IS NULL THEN
            :NEW.MEMBER_ID :=  VV_MEMBER_SQ.NEXTVAL;  
           -- :NEW.REMAIN_LOAN_BALANCE := :NEW.TOTAL_AMT_WITH_INTEREST;
        END IF;
    ELSIF UPDATING THEN
		--:NEW.UPDATED_BY := NVL(GET_USER_ID(v('APP_USER')),1);
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END;
/


create or replace TYPE  AGGR_TYPE  AS OBJECT
(
  g_string  VARCHAR2(32767),

  STATIC FUNCTION ODCIAggregateInitialize(sctx  IN OUT  aggr_type)
    RETURN NUMBER,

  MEMBER FUNCTION ODCIAggregateIterate(self   IN OUT  aggr_type,
                                       value  IN      VARCHAR2 )
     RETURN NUMBER,

  MEMBER FUNCTION ODCIAggregateTerminate(self         IN   aggr_type,
                                         returnValue  OUT  VARCHAR2,
                                         flags        IN   NUMBER)
    RETURN NUMBER,

  MEMBER FUNCTION ODCIAggregateMerge(self  IN OUT  aggr_type,
                                     ctx2  IN      aggr_type)
    RETURN NUMBER
);
/
create or replace TYPE BODY  AGGR_TYPE IS
  STATIC FUNCTION ODCIAggregateInitialize(sctx  IN OUT  aggr_type)
    RETURN NUMBER IS
  BEGIN
    sctx := aggr_type(NULL);
    RETURN ODCIConst.Success;
  END;

  MEMBER FUNCTION ODCIAggregateIterate(self   IN OUT  aggr_type,
                                       value  IN      VARCHAR2 )
    RETURN NUMBER IS
  BEGIN
    SELF.g_string := self.g_string || ',' || value;
    RETURN ODCIConst.Success;
  END;

  MEMBER FUNCTION ODCIAggregateTerminate(self         IN   aggr_type,
                                         returnValue  OUT  VARCHAR2,
                                         flags        IN   NUMBER)
    RETURN NUMBER IS
  BEGIN
    returnValue := RTRIM(LTRIM(SELF.g_string, ','), ',');
    RETURN ODCIConst.Success;
  END;

  MEMBER FUNCTION ODCIAggregateMerge(self  IN OUT  aggr_type,
                                     ctx2  IN      aggr_type)
    RETURN NUMBER IS
  BEGIN
    SELF.g_string := SELF.g_string || ',' || ctx2.g_string;
    RETURN ODCIConst.Success;
  END;
END;
/

create or replace TYPE GET_DAYS AS OBJECT (SRL_NO NUMBER, DAY_ID NUMBER, DT DATE, DAY_DISP VARCHAR2(100), MN NUMBER, YR NUMBER)
/

create or replace TYPE GET_DAYS_TAB AS TABLE OF GET_DAYS
/


create or replace PACKAGE PKG_APP_SECURITY_AUTH
AS
PROCEDURE LOGIN(P_UNAME IN VARCHAR2,P_PASSWORD IN VARCHAR2, P_SESSION_ID IN VARCHAR2,P_FLOW_PAGE IN VARCHAR2);
PROCEDURE VALID_USER2(P_USERNAME IN VARCHAR2,P_PASSWORD IN VARCHAR2);
FUNCTION VALID_USER(P_USERNAME IN VARCHAR2,P_PASSWORD IN VARCHAR2) RETURN BOOLEAN;
END PKG_APP_SECURITY_AUTH;
/


create or replace PACKAGE BODY PKG_APP_SECURITY_AUTH
AS
    PROCEDURE LOGIN(P_UNAME IN VARCHAR2,P_PASSWORD IN VARCHAR2
              ,P_SESSION_ID IN VARCHAR2,P_FLOW_PAGE IN VARCHAR2)
    IS
     LV_GOTO_PAGE NUMBER DEFAULT 1; ----111
    BEGIN
     
     -- This logic is a demonstration of how to redirect
     -- to different pages depending on who successfully
     -- authenticates. In my example, it simply demonstrates
     -- the ADMIN user going to page 1 and all other users going
     -- to page 100. Add you own logic here to detrmin which page
     -- a user should be directed to post authentication.
     IF UPPER(P_UNAME) = 'ADMIN'
     THEN
      LV_GOTO_PAGE := 1; --111
     ELSE
      LV_GOTO_PAGE :=1; --14
     END IF;
     WWV_FLOW_CUSTOM_AUTH_STD.LOGIN
     ( P_UNAME => P_UNAME,P_PASSWORD => P_PASSWORD,P_SESSION_ID => P_SESSION_ID,
       P_FLOW_PAGE => P_FLOW_PAGE || ':' || LV_GOTO_PAGE);
    EXCEPTION
       WHEN OTHERS THEN
            RAISE;
    END LOGIN;
    PROCEDURE VALID_USER2 (P_USERNAME IN VARCHAR2, P_PASSWORD IN VARCHAR2)
    AS
        V_OMS_ID NUMBER;
        V_PWD VARCHAR2(200);
        V_ENT_SQ NUMBER;
        V_DUMMY VARCHAR2 (1);
        VACTIVE NUMBER;
        VRAISE  EXCEPTION;
    BEGIN                                                                      
        SELECT '1' INTO V_DUMMY FROM EMP_USERS
        WHERE LOWER (EMP_CODE) = TRIM (LOWER(P_USERNAME)) AND PWD =  TRIM(P_PASSWORD);
    EXCEPTION    
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR (-20000, 'Invalid username/password, Please check.');
        WHEN VRAISE THEN
            RAISE_APPLICATION_ERROR (-20000, 'Your account is inactive. Please contact with your administrator...');        
    END VALID_USER2;
    FUNCTION VALID_USER (P_USERNAME IN VARCHAR2, P_PASSWORD IN VARCHAR2)
    RETURN BOOLEAN
    AS
    BEGIN
        VALID_USER2 (P_USERNAME, P_PASSWORD);
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN RETURN FALSE;
    END VALID_USER;
END PKG_APP_SECURITY_AUTH;
/


create or replace PROCEDURE CHECK_ANY_PARAM_VALUE (pCHECK_VALUE VARCHAR2)
    AUTHID CURRENT_USER
IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    vCOL_NUMBER   NUMBER;
BEGIN
    SELECT NVL (MAX (COL2), 0)+1 INTO vCOL_NUMBER FROM TEST_CLOB;

    INSERT INTO TEST_CLOB (COL2, COL1)
         VALUES (vCOL_NUMBER, TO_CLOB (pCHECK_VALUE));
    COMMIT;
END;
/

create or replace FUNCTION BL_USER_PAGE_ACCESS(P_PAGE_ID NUMBER)
RETURN BOOLEAN IS
V_COUNT NUMBER;
BEGIN
SELECT COUNT(*) INTO V_COUNT FROM
(
    SELECT 1 FROM BL_USER_ROLE_DTL
    WHERE PAGE_ID = P_PAGE_ID
    AND ROLE_ID IN(SELECT ROLE_ID FROM BL_USER_ROLE WHERE UPPER(USERNAME) = UPPER(V('APP_USER')))
     UNION
     SELECT 1 FROM BL_USER_ROLE_DTL_OTHERS WHERE UPPER(USERNAME) = UPPER(V('APP_USER')) AND PAGE_ID = P_PAGE_ID
);
IF V_COUNT > 0 THEN
RETURN TRUE;
ELSE
RETURN FALSE;
END IF;
END BL_USER_PAGE_ACCESS;
/

create or replace FUNCTION DFN_GET_INST_USER_ID (pUSERNAME VARCHAR2)
   RETURN NUMBER
IS
   vUSERID   NUMBER;
BEGIN
      BEGIN
         SELECT   EMP_ID
           INTO   vUSERID
           FROM   EMP_USERS --inst_users_list
          WHERE   UPPER (EMP_CODE) = UPPER (pUSERNAME);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            vUSERID := NULL;
         WHEN TOO_MANY_ROWS
         THEN
            vUSERID := NULL;
         WHEN OTHERS
         THEN
            vUSERID := NULL;
      END;
   --END IF;
   RETURN vUSERID;
END DFN_GET_INST_USER_ID;
/

create or replace FUNCTION DFN_GET_USER_FULL_NAME (pUSERNAME  VARCHAR2)
RETURN VARCHAR2
IS
    vRETURN VARCHAR2(1000);
BEGIN
    BEGIN
         SELECT   EMP_NAME
           INTO   vRETURN
           FROM   EMP_USERS --inst_users_list
          WHERE   UPPER (EMP_CODE) = UPPER (pUSERNAME);
    EXCEPTION
        WHEN OTHERS THEN NULL;
    END;
    
    RETURN vRETURN;
END DFN_GET_USER_FULL_NAME;
/

create or replace FUNCTION DFN_GET_USER_INST_ID (pUSERNAME  VARCHAR2)
RETURN NUMBER
IS
    vRETURN NUMBER;
BEGIN
    BEGIN
         SELECT   INST_ID
           INTO   vRETURN
           FROM   EMP_USERS
          WHERE   UPPER (EMP_CODE) = UPPER (pUSERNAME);
    EXCEPTION
        WHEN OTHERS THEN NULL;
    END;
    
    RETURN vRETURN;
END DFN_GET_USER_INST_ID;
/

create or replace FUNCTION DFN_GET_BLOCK_ID (pUSERNAME VARCHAR2)
   RETURN VARCHAR2
IS
   vUSER_ROLE   NUMBER;
   vBLOCK_CODE   VARCHAR2(100);
BEGIN

     SELECT   NVL (USER_STATUS, 0)
       INTO   vUSER_ROLE
       FROM   EMP_USERS --inst_users_list
      WHERE   UPPER (EMP_CODE) = UPPER (pUSERNAME);

      IF vUSER_ROLE = 36 THEN
            SELECT LISTAGG(ASSIGN_BLOCK, ', ') WITHIN GROUP (ORDER BY ASSIGN_BLOCK) INTO vBLOCK_CODE FROM EMP_USERS;
      ELSIF vUSER_ROLE != 36 THEN
         SELECT   ASSIGN_BLOCK
           INTO   vBLOCK_CODE
           FROM   EMP_USERS --inst_users_list
          WHERE   UPPER (EMP_CODE) = UPPER (pUSERNAME);
      END IF;
      /*
      BEGIN
         SELECT   ASSIGN_BLOCK
           INTO   vBLOCK_CODE
           FROM   EMP_USERS --inst_users_list
          WHERE   UPPER (EMP_CODE) = UPPER (pUSERNAME);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            SELECT LISTAGG(ASSIGN_BLOCK, ', ') WITHIN GROUP (ORDER BY ASSIGN_BLOCK) INTO vBLOCK_CODE FROM EMP_USERS;
         WHEN TOO_MANY_ROWS
         THEN
            vBLOCK_CODE := NULL;
         WHEN OTHERS
         THEN
            vBLOCK_CODE := NULL;
      END;*/
   --END IF;
   RETURN vBLOCK_CODE;
END DFN_GET_BLOCK_ID;
/

create or replace FUNCTION DFN_GET_ROLE_ID (pUSERNAME VARCHAR2)
   RETURN NUMBER
IS
   vROLE_ID   NUMBER;
BEGIN
      BEGIN
         SELECT   USER_STATUS
           INTO   vROLE_ID
           FROM   EMP_USERS --inst_users_list
          WHERE   UPPER (EMP_CODE) = UPPER (pUSERNAME);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            vROLE_ID := NULL;
         WHEN TOO_MANY_ROWS
         THEN
            vROLE_ID := NULL;
         WHEN OTHERS
         THEN
            vROLE_ID := NULL;
      END;
   --END IF;
   RETURN vROLE_ID;
END DFN_GET_ROLE_ID;
/

CREATE OR REPLACE TYPE SPLITTED AS OBJECT (SRL_NO NUMBER(10), STR_VALUE VARCHAR2(2000));
/

CREATE OR REPLACE TYPE SPLITTED_TAB AS TABLE OF SPLITTED;
/

CREATE OR REPLACE FUNCTION DFN_GET_STRING_SPLITTED (pString       VARCHAR2, pSeparator    VARCHAR2)
RETURN splitted_tab
PIPELINED
IS
   vString   VARCHAR2 (4000) := REPLACE (pString, pSeparator, '~');
BEGIN
   FOR i IN (    SELECT REGEXP_SUBSTR (vString, '[^~]+', 1, LEVEL) val, ROWNUM rid
                   FROM DUAL
             CONNECT BY REGEXP_SUBSTR (vString, '[^~]+', 1, LEVEL) IS NOT NULL)
   LOOP
      PIPE ROW (splitted (i.rid, i.val));
   END LOOP;
EXCEPTION
   WHEN OTHERS
   THEN
      NULL;
END dfn_get_string_splitted;
/

create or replace FUNCTION GET_CLOSING_REPORT (pD1 VARCHAR2, pD2 VARCHAR2, pBLOCK VARCHAR2)
RETURN CLOB
IS
    vDATASET            CLOB;
    vHEADERS            VARCHAR2(4000);
    vSLNO               NUMBER :=1;
    vQRY                VARCHAR2(32000);
    vDatesPart          VARCHAR2(4000);
    vTrTdsPart          VARCHAR2(4000);
    vTrTdsPartSumm      VARCHAR2(4000);
    vBLANK_TD           VARCHAR2(2000);
    vMEMBER_NAME        VARCHAR2(2000);
    TYPE qry_cur IS REF CURSOR;
    qry_cursor          qry_cur;
    vNO_OF_DAYS         NUMBER;
    vCOUNTER            NUMBER := 1;
    vTR_REC             VARCHAR2(4000);
    vWITHDRAW_ROW       NUMBER := 0;
    vWITHDRAW           NUMBER := 0;
    vDATE_FROM          VARCHAR2(40) := TO_CHAR(TO_DATE(pD1),'DD-MON-RR');
    vDATE_TO            VARCHAR2(40) := TO_CHAR(TO_DATE(pD1),'DD-MON-RR');
BEGIN

    vDATASET := vDATASET||' <input id="b_print" type="button" class="t-Button01_526" style="float:right;"  onclick="printdiv(''div_print'');" value=" Print " onload="openWindow.print()">';
    vDATASET := vDATASET||' <input id="b_print" type="button" class="t-Button02_526" style="float:right;"  onClick="tableToExcel(''div_print'');" value=" Excel ">'; 
    vDATASET := vDATASET||'<div id="div_print" class="table-scroll">';  

    vNO_OF_DAYS := (TO_DATE(pD2,'DDMMRRRR') - TO_DATE(pD1,'DDMMRRRR')) + 1;

    
    FOR I IN 1..vNO_OF_DAYS LOOP
    
        vDatesPart := CASE WHEN vCOUNTER = 1 THEN 'SUM (DECODE (DID.SRL_NO,'||vCOUNTER||',NVL(COLLECTION_AMOUT,0))) D'||vCOUNTER||','
                           WHEN vCOUNTER > 1 THEN vDatesPart||'SUM (DECODE (DID.SRL_NO,'||vCOUNTER||',NVL(COLLECTION_AMOUT,0))) D'||vCOUNTER||',' END;
    
        vTrTdsPart := CASE WHEN vCOUNTER = 1 THEN '||''<td>''||D'||vCOUNTER ELSE vTrTdsPart||'||''</td><td>''||D'||vCOUNTER END ;
        
        vTrTdsPartSumm := CASE WHEN vCOUNTER = 1 THEN '||''<td>''||SUM (D'||vCOUNTER||')' ELSE vTrTdsPartSumm||'||''</td><td>''||SUM (D'||vCOUNTER||')' END ;
        
        vBLANK_TD       := CASE WHEN vCOUNTER = 1 THEN '<td></td>' ELSE vBLANK_TD||'<td></td>' END ;
        
        vCOUNTER := vCOUNTER + 1;

    END LOOP;

    

    SELECT EMP_NAME INTO vMEMBER_NAME FROM EMP_USERS WHERE ASSIGN_BLOCK = pBLOCK AND STATUS = 1;


    vDATASET := vDATASET||'
        <div class="header-info">
                <h1 class="m-0">Bhai Bhai Shramjibi Cooperative Society Ltd.</h1> 
                <h4 class="m-0">Address: 24/2 Maniknagar,Mugda, Wari, Dhaka-1203</h4>
                <h3 class="m-0">Closing Report</h3>
        </div>

        <hr>

        <div class="coll-info">
            <p style="font-weight:bold;">Field Officer: '||vMEMBER_NAME||' </p>
            <p style="font-weight:bold;">Block: '||pBLOCK||'</p>
            <p style="font-weight:bold;">Statement Period:'||vDATE_FROM||' to '||vDATE_TO||'</p> 
        </div>
    ';

vDATASET := vDATASET||'
<table>

    <thead>
        <tr>
            <th>SL#</th>
            <th>Member Name</th>
            <th>Account No.</th>
            <th>Joining Date</th>
            <th>Weekly Remain</th>';

            FOR I IN (SELECT * FROM (GET_DAYS_LIST (TO_DATE(pD1,'DDMMRRRR'),TO_DATE(pD2,'DDMMRRRR'),'DD-MON-RR')) ORDER BY SRL_NO) LOOP

                vDATASET := vDATASET||'<th>'||I.DAY_DISP||'</th>';

            END LOOP;

vDATASET := vDATASET||'            
            <th>Total Collection</th>
            <th>Total Withdraw</th>
            <th>Balance</th>
        </tr>
    </thead>
    
    <tbody> 
     ';

    vQRY    := 
    'SELECT WITHDRAW, ''<tr><td>''||SL_NO||''</td><td>''||MEMBER_NAME||''</td><td>''||ACCOUNT_NO||''</td><td>''||TO_CHAR (JOINING_DATE,''DD-MON-RR'')||''</td>
    <td style="color:green; font-weight:bold; background: rgb(230, 230, 230);">''||WEEKLY_REMAINNG||''</td>'''||vTrTdsPart||'||''<td>''||COLLECTION_AMOUT||''</td><td>''||WITHDRAW||''</td><td style="color:green; font-weight:bold; background: rgb(230, 230, 230);">''||REMAINING||''</td></tr>'' TR
FROM (
SELECT A.*, ROWNUM SL_NO FROM (        
SELECT VM.MEMBER_NAME, VM.ACCOUNT_NO, VM.JOINING_DATE,  MAX(NVL(DRWITHDRAW_AMT.WITHDRAW_AMT,0)) WITHDRAW, (SUM(NVL(VDC.COLLECTION_AMOUT,0)) -  MAX(NVL(DRWITHDRAW_AMT.WITHDRAW_AMT,0))) + MAX(NVL(WEEK_REM.WEEKLY_REMAINING,0))  REMAINING, 
CASE WHEN SUM (DECODE (NVL (VDC.COLLECTION_AMOUT, 0),0,0,1)) = 0 THEN SUM(NVL(WEEK_REM.WEEKLY_REMAINING,0))
ELSE
SUM(NVL(WEEK_REM.WEEKLY_REMAINING,0))/SUM (DECODE (NVL (VDC.COLLECTION_AMOUT, 0),0,0,1))
END WEEKLY_REMAINNG,
'||vDatesPart||'
SUM(NVL(VDC.COLLECTION_AMOUT,0)) COLLECTION_AMOUT
FROM (SELECT * FROM VV_MEMBER WHERE BLOCK_CODE = '''||pBLOCK||''') VM
LEFT JOIN (SELECT * FROM VV_DAILY_COLLECTION
           WHERE COLLECTION_DATE BETWEEN TO_DATE('''||pD1||''',''DDMMRRRR'') AND TO_DATE('''||pD2||''',''DDMMRRRR'') AND IS_POST = ''Y'') VDC ON VM.MEMBER_ID = VDC.MEMBER_ID
LEFT JOIN VV_CLOSING_SCHEDULE VCS ON VCS.SCHEDULE_ID = VDC.SCHEDULE_ID
LEFT JOIN (SELECT * FROM (GET_DAYS_LIST (TO_DATE('''||pD1||''',''DDMMRRRR''),TO_DATE('''||pD2||''',''DDMMRRRR''),''DD-MON-RR''))) DID ON DID.DT = VDC.COLLECTION_DATE
LEFT JOIN (
SELECT VCW.MEMBER_ID,
--VCW.WITHDRAW_DATE,   
SUM(VCW.WITHDRAW_AMT) WITHDRAW_AMT
FROM VV_COLL_WITHDRAW VCW
LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VCW.MEMBER_ID
LEFT JOIN VV_CLOSING_SCHEDULE VCS ON VCS.SCHEDULE_ID = VCW.SCHEDULE_ID
WHERE  VCW.WITHDRAW_DATE BETWEEN TO_DATE('''||pD1||''',''DDMMRRRR'') AND TO_DATE('''||pD2||''',''DDMMRRRR'') AND VM.BLOCK_CODE = '''||pBLOCK||'''
GROUP BY VCW.MEMBER_ID--, VCW.WITHDRAW_DATE
) DRWITHDRAW_AMT ON DRWITHDRAW_AMT.MEMBER_ID = VM.MEMBER_ID
LEFT JOIN (
SELECT VDC.MEMBER_ID,  SUM(NVL(COLLECTION_AMOUT,0)) -  MAX(NVL(WITHDRAW_AMT.WITHDRAW_AMT,0))  WEEKLY_REMAINING
FROM VV_DAILY_COLLECTION VDC
LEFT JOIN (
SELECT VCW.MEMBER_ID,
--VCW.WITHDRAW_DATE,   
SUM(VCW.WITHDRAW_AMT) WITHDRAW_AMT
FROM VV_COLL_WITHDRAW VCW
LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VCW.MEMBER_ID
LEFT JOIN VV_CLOSING_SCHEDULE VCS ON VCS.SCHEDULE_ID = VCW.SCHEDULE_ID
WHERE  VCW.WITHDRAW_DATE < TO_DATE('''||pD1||''',''DDMMRRRR'') 
GROUP BY VCW.MEMBER_ID--, VCW.WITHDRAW_DATE
) WITHDRAW_AMT ON WITHDRAW_AMT.MEMBER_ID = VDC.MEMBER_ID
WHERE VDC.COLLECTION_DATE < TO_DATE('''||pD1||''',''DDMMRRRR'')  AND VDC.IS_POST = ''Y'' 
GROUP BY  VDC.MEMBER_ID
) WEEK_REM ON WEEK_REM.MEMBER_ID = VM.MEMBER_ID
GROUP BY VM.MEMBER_NAME, VM.ACCOUNT_NO, VM.JOINING_DATE
ORDER BY VM.ACCOUNT_NO
) A
--WHERE WEEKLY_REMAINNG > 0 OR REMAINING > 0
)';

    --- DATA ROWS   vDATASET := vDATASET||'<tbody> 
    --DBMS_OUTPUT.PUT_LINE (vQRY);
    check_any_param_value(vQRY);
   OPEN qry_cursor FOR vQRY;
   
   LOOP
   
       FETCH qry_cursor INTO vWITHDRAW_ROW, vTR_REC;
       vWITHDRAW := vWITHDRAW + vWITHDRAW_ROW;
       vWITHDRAW_ROW:= 0;
       EXIT WHEN qry_cursor%notfound;
       
       vDATASET := vDATASET||vTR_REC;
       
       
   
   END LOOP;
   
    vQRY    := 
    'SELECT ''<tr><td colspan="4" style="color:red; font-weight:bold; background: rgb(230, 230, 230);">Total</td>
    <td style="color:red; font-weight:bold; background: rgb(230, 230, 230);">''||SUM (WEEKLY_REMAINNG)||''</td>'''||vTrTdsPartSumm||'||''<td style="color:red; font-weight:bold; background: rgb(230, 230, 230);">''||SUM (COLLECTION_AMOUT)||''</td>
    <td style="color:red; font-weight:bold; background: rgb(230, 230, 230);">''||'||vWITHDRAW||'||''</td><td style="color:red; font-weight:bold; background: rgb(230, 230, 230);">''||((SUM (COLLECTION_AMOUT) - '||vWITHDRAW||')+SUM (WEEKLY_REMAINNG)) ||''</td></tr>'' TR
FROM (
SELECT A.*, ROWNUM SL_NO FROM (        
SELECT VM.MEMBER_NAME, VM.ACCOUNT_NO, VM.JOINING_DATE,  MAX(NVL(DRWITHDRAW_AMT.WITHDRAW_AMT,0)) WITHDRAW, (SUM(NVL(VDC.COLLECTION_AMOUT,0)) -  MAX(NVL(DRWITHDRAW_AMT.WITHDRAW_AMT,0))) + MAX(NVL(WEEK_REM.WEEKLY_REMAINING,0))  REMAINING, 
CASE WHEN SUM (DECODE (NVL (VDC.COLLECTION_AMOUT, 0),0,0,1)) = 0 THEN SUM(NVL(WEEK_REM.WEEKLY_REMAINING,0))
ELSE
SUM(NVL(WEEK_REM.WEEKLY_REMAINING,0))/SUM (DECODE (NVL (VDC.COLLECTION_AMOUT, 0),0,0,1))
END WEEKLY_REMAINNG,
'||vDatesPart||'
SUM(NVL(VDC.COLLECTION_AMOUT,0)) COLLECTION_AMOUT
FROM (SELECT * FROM VV_MEMBER WHERE BLOCK_CODE = '''||pBLOCK||''') VM
LEFT JOIN (SELECT * FROM VV_DAILY_COLLECTION
           WHERE COLLECTION_DATE BETWEEN TO_DATE('''||pD1||''',''DDMMRRRR'') AND TO_DATE('''||pD2||''',''DDMMRRRR'') AND IS_POST = ''Y'') VDC ON VM.MEMBER_ID = VDC.MEMBER_ID
LEFT JOIN VV_CLOSING_SCHEDULE VCS ON VCS.SCHEDULE_ID = VDC.SCHEDULE_ID
LEFT JOIN (SELECT * FROM (GET_DAYS_LIST (TO_DATE('''||pD1||''',''DDMMRRRR''),TO_DATE('''||pD2||''',''DDMMRRRR''),''DD-MON-RR''))) DID ON DID.DT = VDC.COLLECTION_DATE
LEFT JOIN (
SELECT VCW.MEMBER_ID,
--VCW.WITHDRAW_DATE,   
SUM(VCW.WITHDRAW_AMT) WITHDRAW_AMT
FROM VV_COLL_WITHDRAW VCW
LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VCW.MEMBER_ID
LEFT JOIN VV_CLOSING_SCHEDULE VCS ON VCS.SCHEDULE_ID = VCW.SCHEDULE_ID
WHERE  VCW.WITHDRAW_DATE BETWEEN TO_DATE('''||pD1||''',''DDMMRRRR'') AND TO_DATE('''||pD2||''',''DDMMRRRR'') AND VM.BLOCK_CODE = '''||pBLOCK||'''
GROUP BY VCW.MEMBER_ID--, VCW.WITHDRAW_DATE
) DRWITHDRAW_AMT ON DRWITHDRAW_AMT.MEMBER_ID = VM.MEMBER_ID
LEFT JOIN (
SELECT VDC.MEMBER_ID,  SUM(NVL(COLLECTION_AMOUT,0)) -  MAX(NVL(WITHDRAW_AMT.WITHDRAW_AMT,0))  WEEKLY_REMAINING
FROM VV_DAILY_COLLECTION VDC
LEFT JOIN (
SELECT VCW.MEMBER_ID,
--VCW.WITHDRAW_DATE,   
SUM(VCW.WITHDRAW_AMT) WITHDRAW_AMT
FROM VV_COLL_WITHDRAW VCW
LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VCW.MEMBER_ID
LEFT JOIN VV_CLOSING_SCHEDULE VCS ON VCS.SCHEDULE_ID = VCW.SCHEDULE_ID
WHERE  VCW.WITHDRAW_DATE < TO_DATE('''||pD1||''',''DDMMRRRR'') 
GROUP BY VCW.MEMBER_ID---, VCW.WITHDRAW_DATE
) WITHDRAW_AMT ON WITHDRAW_AMT.MEMBER_ID = VDC.MEMBER_ID
WHERE VDC.COLLECTION_DATE < TO_DATE('''||pD1||''',''DDMMRRRR'')  AND VDC.IS_POST = ''Y'' 
GROUP BY  VDC.MEMBER_ID
) WEEK_REM ON WEEK_REM.MEMBER_ID = VM.MEMBER_ID
GROUP BY VM.MEMBER_NAME, VM.ACCOUNT_NO, VM.JOINING_DATE
ORDER BY VM.ACCOUNT_NO
) A
)';

    --- DATA ROWS   vDATASET := vDATASET||'<tbody> 
    --DBMS_OUTPUT.PUT_LINE (vQRY);
    check_any_param_value(vQRY);
   OPEN qry_cursor FOR vQRY;
   
   LOOP
   
       FETCH qry_cursor INTO vTR_REC;
       EXIT WHEN qry_cursor%notfound;
       
       vDATASET := vDATASET||vTR_REC;
       
       
   
   END LOOP;



vDATASET := vDATASET||'   

        <tr>
            <td colspan="4">Subervisar Sign</td>
            <td></td>
            '||vBLANK_TD||'
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td colspan="4">Accountant Sign</td>
            <td></td>
            '||vBLANK_TD||'
            <td></td>
            <td></td>
            <td></td>
        </tr>
        
    </tbody>

</table>
<p style="font-weight:bold;">Print:'||TO_CHAR(SYSDATE,'DD MON RRRR HH24:MI:SS')||'</p> 
 ';

 RETURN vDATASET;
EXCEPTION
WHEN OTHERS THEN check_any_param_value(SQLERRM);
    
END GET_CLOSING_REPORT;
/


create or replace FUNCTION GET_DAYS_LIST (pDATE_FROM DATE, pDATE_TO DATE, pFORMAT VARCHAR2)
RETURN GET_DAYS_TAB
PIPELINED
IS
    vNO_OF_DAYS NUMBER := (pDATE_TO - pDATE_FROM) + 1;
    vDATE   DATE := pDATE_FROM; 
    vSRL_NO NUMBER := 1;
BEGIN

    FOR I IN 1..vNO_OF_DAYS LOOP
        --GET_DAYS AS OBJECT (SRL_NO NUMBER, DAY_ID NUMBER, DT DATE, DAY_DISP VARCHAR2(100), MN NUMBER, YR NUMBER)
        PIPE ROW (GET_DAYS (vSRL_NO, TO_NUMBER (TO_CHAR (vDATE,'DD')), vDATE, TO_CHAR (vDATE,pFORMAT), TO_NUMBER (TO_CHAR (vDATE,'MM')),TO_NUMBER (TO_CHAR (vDATE,'RRRR'))));
        
        vDATE   :=  vDATE + 1;
        vSRL_NO :=  vSRL_NO +   1;
    
    END LOOP;

END GET_DAYS_LIST;
/

create or replace FUNCTION GET_LOAN_COLL_REPORT (pD1 VARCHAR2, pD2 VARCHAR2,pBLOCK VARCHAR2)
RETURN CLOB
IS
    vDATASET            CLOB; 
    vQRY                VARCHAR2(32000);
    vDatesPart          VARCHAR2(4000);
    vTrTdsPart          VARCHAR2(4000);
    vTrTdsPartSumm      VARCHAR2(4000);
    vBLANK_TD           VARCHAR2(2000);
    TYPE qry_cur IS REF CURSOR;
    qry_cursor          qry_cur;
    
    vNO_OF_DAYS         NUMBER;
    vMEMBER_NAME        VARCHAR2(100);
    vCOUNTER            NUMBER := 1;
    vTR_REC             VARCHAR2(4000);
BEGIN

    vDATASET := vDATASET||' <input id="b_print" type="button" class="t-Button01_526" style="float:right;"  onclick="printdiv(''div_print'');" value=" Print " onload="openWindow.print()">';
    vDATASET := vDATASET||' <input id="b_print" type="button" class="t-Button02_526" style="float:right;"  onClick="tableToExcel(''div_print'');" value=" Excel ">'; 
    vDATASET := vDATASET||'<div id="div_print">';    

    vNO_OF_DAYS := (TO_DATE(pD2,'DDMMRRRR') - TO_DATE(pD1,'DDMMRRRR')) + 1;
    
        FOR I IN 1..vNO_OF_DAYS LOOP
    
        vDatesPart := CASE WHEN vCOUNTER = 1 THEN 'SUM (DECODE (SRL_NO,'||vCOUNTER||',NVL(DR_COLL_AMT,0))) D'||vCOUNTER||','
                           WHEN vCOUNTER > 1 THEN vDatesPart||'SUM (DECODE (SRL_NO,'||vCOUNTER||',NVL(DR_COLL_AMT,0))) D'||vCOUNTER||',' END;
    
        vTrTdsPart := CASE WHEN vCOUNTER = 1 THEN '||''<td>''||D'||vCOUNTER ELSE vTrTdsPart||'||''</td><td>''||D'||vCOUNTER end ;
        
        vTrTdsPartSumm := CASE WHEN vCOUNTER = 1 THEN '||''<td>''||SUM (D'||vCOUNTER||')' else vTrTdsPartSumm||'||''</td><td>''||SUM (D'||vCOUNTER||')' end ;
        
        vBLANK_TD       := CASE WHEN vCOUNTER = 1 THEN '<td></td>' else vBLANK_TD||'<td></td>' end ;
        
        vCOUNTER := vCOUNTER + 1;

    END LOOP;
    
    SELECT EMP_NAME 
      INTO vMEMBER_NAME 
      FROM EMP_USERS
     WHERE ASSIGN_BLOCK = pBLOCK AND STATUS = 1;

    vDATASET := vDATASET||'
        <div class="header-info">
                <!-- Vai Vai Cooperative  Society Limited. -->
                <h1 class="m-0">Bhai Bhai Shramjibi Cooperative Society Ltd. </h1> 
                <h4 class="m-0">Address: 24/2 Maniknagar,Mugda, Wari, Dhaka-1203</h4>
                <h3 class="m-0">Loan Report</h3>
        </div>

        <hr>
        
        <div class="coll-info">
            <p style="font-weight:bold;">Field Officer:'||vMEMBER_NAME||' </p>
            <p style="font-weight:bold;">Block: '||pBLOCK||'</p>
            <p style="font-weight:bold;">Date:'||TO_CHAR(SYSDATE,'DD MON RRRR HH24:MI:SS')||'</p>
        </div>
    ';


vDATASET := vDATASET||'
<table>

    <thead>
        <tr>
            <!-- <th colspan="4">Collection</th>
            <th colspan="4">Loan</th> -->
        </tr>
        <tr>
            <th>SL#</th>
            <th>Member Name</th>
            <th>Loan No.</th>
            <th>Joining Date</th>
            <th>Opening Balance</th>';

            FOR I IN (SELECT * FROM (GET_DAYS_LIST (TO_DATE(pD1,'DDMMRRRR'),TO_DATE(pD2,'DDMMRRRR'),'DD-MON-RR')) ORDER BY SRL_NO) LOOP
 
                vDATASET := vDATASET||'<th>'||I.DAY_DISP||'</th>';

            END LOOP;



vDATASET := vDATASET||'            
            <th>Total Collection</th>
            <th>Balance</th>
        </tr>
    </thead>
    <tbody>   
     ';

  vQRY    := 
 'SELECT ''<tr><td>''||SL_NO||''</td><td>''||MEMBER_NAME||''</td><td>''||LOAN_ID||''</td><td>''||TO_CHAR (JOINING_DATE,''DD-MON-RR'')||''</td>
 <td style="color:green; font-weight:bold; background: rgb(230, 230, 230);text-align:right;">''||WEEKLY_REMAINNG||''</td>'''||vTrTdsPart||'||''<td>''||NVL(COLLECTION_AMOUT,0)||''</td><td style="color:green; font-weight:bold; background: rgb(230, 230, 230);">''||REMAINING||''</td></tr>'' TR
FROM (
    SELECT A.*, ROWNUM SL_NO 
      FROM (
            SELECT MEMBER_ID, MEMBER_NAME, LOAN_ID, JOINING_DATE, MAX (WEEKLY_REMAINNG) WEEKLY_REMAINNG, MAX (REMAINING_BAL) REMAINING,
                   '||vDatesPart||'
                   SUM (NVL (DR_COLL_AMT,0)) COLLECTION_AMOUT
              FROM
                (
                SELECT VM.*,DTRCOL.SRL_NO, DTRCOL.LOAN_DATE LOAN_DATE,DTRCOL.DR_COLL_AMT
                  FROM
                    (
                    SELECT VM.*, COL.COLL_AMT, VM.TOTAL_AMT_WITH_INTEREST - NVL (COL.COLL_AMT, 0) WEEKLY_REMAINNG, NVL (DTRCOL.DR_TOT_COLL, 0) DR_TOT_COLL,
                           VM.TOTAL_AMT_WITH_INTEREST - NVL (COL.COLL_AMT, 0) - NVL (DTRCOL.DR_TOT_COLL, 0) REMAINING_BAL
                            --, --DTRCOL.SRL_NO, DTRCOL.LOAN_DATE LOAN_DATE,DTRCOL.DR_COLL_AMT, DTRCOLR.NROWS
                      FROM  (SELECT VAL.APPLY_ID,VAL.APPLY_DATE JOINING_DATE, VAL.LOAN_ID, 
                                    VAL.REMAIN_LOAN_BALANCE,VAL.MEMBER_ID, VM.MEMBER_NAME, VAL.TOTAL_AMT_WITH_INTEREST  
                               FROM VV_MEMBER VM
                               JOIN VV_APPLY_LOAN VAL ON VM.MEMBER_ID = VAL.MEMBER_ID 
                              WHERE VM.BLOCK_CODE = '''||pBLOCK||'''   --AND VAL.LOAN_ID = 10
                                AND APPLY_DATE <= TO_DATE('''||pD2||''',''DDMMRRRR'')) VM 
                      LEFT JOIN (SELECT APPLY_ID, SUM (LOAN_AMOUT) COLL_AMT 
                                   FROM VV_DAILY_LOAN_COLL 
                                  WHERE LOAN_DATE < TO_DATE('''||pD1||''',''DDMMRRRR'') AND IS_POST = ''Y'' --AND APPLY_ID = 269
                                  GROUP BY APPLY_ID) COL ON COL.APPLY_ID = VM.APPLY_ID
                      LEFT JOIN (SELECT APPLY_ID, SUM (LOAN_AMOUT) DR_TOT_COLL 
                                   FROM VV_DAILY_LOAN_COLL VDLC 
                                   LEFT JOIN (SELECT * FROM (GET_DAYS_LIST (TO_DATE('''||pD1||''',''DDMMRRRR''),TO_DATE('''||pD2||''',''DDMMRRRR''),''DD-MON-RR''))) DID ON DID.DT = VDLC.LOAN_DATE
                                  WHERE LOAN_DATE BETWEEN TO_DATE('''||pD1||''',''DDMMRRRR'') AND TO_DATE('''||pD2||''',''DDMMRRRR'') --AND APPLY_ID = 269
                                  GROUP BY APPLY_ID) DTRCOL 
                                ON DTRCOL.APPLY_ID = VM.APPLY_ID
                    ) VM
                      LEFT JOIN (SELECT DID.SRL_NO, APPLY_ID, LOAN_DATE, SUM (LOAN_AMOUT) DR_COLL_AMT 
                                   FROM VV_DAILY_LOAN_COLL VDLC 
                                   LEFT JOIN (SELECT * FROM (GET_DAYS_LIST (TO_DATE('''||pD1||''',''DDMMRRRR''),TO_DATE('''||pD2||''',''DDMMRRRR''),''DD-MON-RR''))) DID ON DID.DT = VDLC.LOAN_DATE
                                  WHERE LOAN_DATE BETWEEN TO_DATE('''||pD1||''',''DDMMRRRR'') AND TO_DATE('''||pD2||''',''DDMMRRRR'') --AND APPLY_ID = 269
                                  GROUP BY DID.SRL_NO, APPLY_ID, LOAN_DATE) DTRCOL 
                                ON DTRCOL.APPLY_ID = VM.APPLY_ID
                )
             GROUP BY MEMBER_ID, MEMBER_NAME, LOAN_ID, JOINING_DATE   
             ORDER BY LOAN_ID
        ) A
     WHERE (NVL (WEEKLY_REMAINNG,0) <> 0 OR NVL (REMAINING,0) <> 0) 
      )
    ';
       --- DATA ROWS   vDATASET := vDATASET||'<tbody> 
    --DBMS_OUTPUT.PUT_LINE (vQRY);

   CHECK_ANY_PARAM_VALUE (vQRY);
   
   OPEN qry_cursor FOR vQRY;
   
   LOOP
   
       FETCH qry_cursor INTO vTR_REC;
       EXIT WHEN qry_cursor%notfound;
       
       vDATASET := vDATASET||vTR_REC;
       
       
   
   END LOOP;
       
     
vQRY    := 
  'SELECT ''<tr><td colspan="4" style="color:red; font-weight:bold; background: rgb(230, 230, 230);">Total</td><td style="color:red; font-weight:bold; background: rgb(230, 230, 230);text-align:right;">''||SUM (NVL(WEEKLY_REMAINNG,0))||''</td>'''||vTrTdsPartSumm||'||''
  <td style="color:red; font-weight:bold; background: rgb(230, 230, 230);">''||SUM (NVL(COLLECTION_AMOUT,0))||''</td><td style="color:red; font-weight:bold; background: rgb(230, 230, 230);">''||SUM (NVL(REMAINING,0))||''</td></tr>'' TR
FROM (
    SELECT A.*, ROWNUM SL_NO 
      FROM (    
            SELECT MEMBER_ID, MEMBER_NAME, LOAN_ID, JOINING_DATE, MAX (WEEKLY_REMAINNG) WEEKLY_REMAINNG, MAX (REMAINING_BAL) REMAINING,
                   '||vDatesPart||'
                   SUM (NVL (DR_COLL_AMT,0)) COLLECTION_AMOUT
              FROM
                (
                SELECT VM.*,DTRCOL.SRL_NO, DTRCOL.LOAN_DATE LOAN_DATE,DTRCOL.DR_COLL_AMT
                  FROM
                    (
                    SELECT VM.*, COL.COLL_AMT, VM.TOTAL_AMT_WITH_INTEREST - NVL (COL.COLL_AMT, 0) WEEKLY_REMAINNG, NVL (DTRCOL.DR_TOT_COLL, 0) DR_TOT_COLL,
                           VM.TOTAL_AMT_WITH_INTEREST - NVL (COL.COLL_AMT, 0) - NVL (DTRCOL.DR_TOT_COLL, 0) REMAINING_BAL
                            --, --DTRCOL.SRL_NO, DTRCOL.LOAN_DATE LOAN_DATE,DTRCOL.DR_COLL_AMT, DTRCOLR.NROWS
                      FROM  (SELECT VAL.APPLY_ID,VAL.APPLY_DATE JOINING_DATE, VAL.LOAN_ID, 
                                    VAL.REMAIN_LOAN_BALANCE,VAL.MEMBER_ID, VM.MEMBER_NAME, VAL.TOTAL_AMT_WITH_INTEREST  
                               FROM VV_MEMBER VM
                               JOIN VV_APPLY_LOAN VAL ON VM.MEMBER_ID = VAL.MEMBER_ID 
                              WHERE VM.BLOCK_CODE = '''||pBLOCK||'''   --AND VAL.LOAN_ID = 10
                                AND APPLY_DATE <= TO_DATE('''||pD2||''',''DDMMRRRR'')) VM 
                      LEFT JOIN (SELECT APPLY_ID, SUM (LOAN_AMOUT) COLL_AMT 
                                   FROM VV_DAILY_LOAN_COLL 
                                  WHERE LOAN_DATE < TO_DATE('''||pD1||''',''DDMMRRRR'') AND IS_POST = ''Y'' --AND APPLY_ID = 269
                                  GROUP BY APPLY_ID) COL ON COL.APPLY_ID = VM.APPLY_ID
                      LEFT JOIN (SELECT APPLY_ID, SUM (LOAN_AMOUT) DR_TOT_COLL 
                                   FROM VV_DAILY_LOAN_COLL VDLC 
                                   LEFT JOIN (SELECT * FROM (GET_DAYS_LIST (TO_DATE('''||pD1||''',''DDMMRRRR''),TO_DATE('''||pD2||''',''DDMMRRRR''),''DD-MON-RR''))) DID ON DID.DT = VDLC.LOAN_DATE
                                  WHERE LOAN_DATE BETWEEN TO_DATE('''||pD1||''',''DDMMRRRR'') AND TO_DATE('''||pD2||''',''DDMMRRRR'') --AND APPLY_ID = 269
                                  GROUP BY APPLY_ID) DTRCOL 
                                ON DTRCOL.APPLY_ID = VM.APPLY_ID
                    ) VM
                      LEFT JOIN (SELECT DID.SRL_NO, APPLY_ID, LOAN_DATE, SUM (LOAN_AMOUT) DR_COLL_AMT 
                                   FROM VV_DAILY_LOAN_COLL VDLC 
                                   LEFT JOIN (SELECT * FROM (GET_DAYS_LIST (TO_DATE('''||pD1||''',''DDMMRRRR''),TO_DATE('''||pD2||''',''DDMMRRRR''),''DD-MON-RR''))) DID ON DID.DT = VDLC.LOAN_DATE
                                  WHERE LOAN_DATE BETWEEN TO_DATE('''||pD1||''',''DDMMRRRR'') AND TO_DATE('''||pD2||''',''DDMMRRRR'') --AND APPLY_ID = 269
                                  GROUP BY DID.SRL_NO, APPLY_ID, LOAN_DATE) DTRCOL 
                                ON DTRCOL.APPLY_ID = VM.APPLY_ID
                )
             GROUP BY MEMBER_ID, MEMBER_NAME, LOAN_ID, JOINING_DATE   
             ORDER BY LOAN_ID   
            ) A
        )
    ';
    
    --- DATA ROWS   vDATASET := vDATASET||'<tbody> 
    DBMS_OUTPUT.PUT_LINE (vQRY);
   OPEN qry_cursor FOR vQRY;
   
   LOOP
   
       FETCH qry_cursor INTO vTR_REC;
       EXIT WHEN qry_cursor%notfound;
       
       vDATASET := vDATASET||vTR_REC;
       
       
   
   END LOOP;

vDATASET := vDATASET||'   

        <tr>
            <td colspan="4">Subervisar Sign</td>
            <td></td>
            '||vBLANK_TD||'
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td colspan="4">Accountant Sign</td>
            <td></td>
            '||vBLANK_TD||'
            <td></td>
            <td></td>
        </tr>
        
        
    </tbody>

</table>
<p style="font-weight:bold;">Date:'||TO_CHAR(SYSDATE,'DD MON RRRR HH24:MI:SS')||'</p>
 ';

 RETURN vDATASET;
    
END GET_LOAN_COLL_REPORT;
/





create or replace FUNCTION  local_wm_concat(p_input VARCHAR2)
RETURN VARCHAR2
PARALLEL_ENABLE AGGREGATE USING aggr_type;
/


/*
DECLARE
     vDATASET    CLOB;
     vHEADERS    VARCHAR2(4000);
     vSLNO       NUMBER :=1;
     vCOL_AMT    NUMBER;
     vOPEN_BAL   NUMBER;
     vNOW_BAL    NUMBER;
     vWITH_AMT   NUMBER;
BEGIN

    SELECT SUM(VDC.COLLECTION_AMOUT) COLLECTION_AMOUT, MAX(OPENING.OPEN_BAL) OPEN_BAL, MAX(NVL(EXIST_BAL.NOW_BAL,BAL.BALANCE)) NOW_BAL, MAX(WITHDRAW_BAL.WITHDRAW_AMT) WITHDRAW_AMT--, MAX(BAL.BALANCE) BALANCE
           INTO vCOL_AMT, vOPEN_BAL, vNOW_BAL, vWITH_AMT
    FROM VV_DAILY_COLLECTION VDC
    LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VDC.MEMBER_ID
    LEFT JOIN (
        -- BEFORE FROM DATE COLLECTED AMOUNT
        SELECT VDC.MEMBER_ID, SUM(VDC.COLLECTION_AMOUT) OPEN_BAL
        FROM VV_DAILY_COLLECTION VDC
        LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VDC.MEMBER_ID 
        WHERE VDC.COLLECTION_DATE < :P40_DATE_FROM
         AND VM.ACCOUNT_NO = :P40_ACCOUNT_NO
        GROUP BY VDC.MEMBER_ID
    ) OPENING ON OPENING.MEMBER_ID = VDC.MEMBER_ID
    LEFT JOIN (
        --- AFTER TO DATE COLLECTED AMOUNT
        SELECT VDC.MEMBER_ID, SUM(VDC.COLLECTION_AMOUT) NOW_BAL
        FROM VV_DAILY_COLLECTION VDC
        LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VDC.MEMBER_ID 
        WHERE VDC.COLLECTION_DATE > :P40_DATE_TO
         AND VM.ACCOUNT_NO = :P40_ACCOUNT_NO
        GROUP BY VDC.MEMBER_ID
    ) EXIST_BAL ON EXIST_BAL.MEMBER_ID = VDC.MEMBER_ID
    LEFT JOIN 
                (
                    ----- REMAIN BALANCE COLLECTED AMOUNT
                    SELECT (A.COL_AMT - A.WITHDRAW_AMT) BALANCE , A.MEMBER_ID
                    FROM 
                        (
                            SELECT MAX(NVL(COLL.COL_AMT,0)) COL_AMT, SUM(NVL(WITHDRAW_AMT,0)) WITHDRAW_AMT, COLL.MEMBER_ID
                            FROM 
                                (
                                    SELECT SUM(NVL(VDC.COLLECTION_AMOUT,0)) COL_AMT, VDC.MEMBER_ID
                                    FROM VV_DAILY_COLLECTION VDC
                                     LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VDC.MEMBER_ID
                                    WHERE VM.ACCOUNT_NO = :P40_ACCOUNT_NO 
                                    GROUP BY VDC.MEMBER_ID
                                ) COLL
                            LEFT JOIN VV_COLL_WITHDRAW VCW ON VCW.MEMBER_ID =  COLL.MEMBER_ID
                            GROUP BY COLL.MEMBER_ID
                        ) A 
                ) BAL ON BAL.MEMBER_ID = VDC.MEMBER_ID
     LEFT JOIN 
                (
                    SELECT SUM(VCW.WITHDRAW_AMT) WITHDRAW_AMT, VCW.MEMBER_ID
                     FROM VV_COLL_WITHDRAW VCW
                     LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VCW.MEMBER_ID
                     WHERE VM.ACCOUNT_NO = :P40_ACCOUNT_NO 
                       AND VCW.WITHDRAW_DATE BETWEEN :P40_DATE_FROM AND  :P40_DATE_TO
                     GROUP BY VCW.MEMBER_ID 
                ) WITHDRAW_BAL ON WITHDRAW_BAL.MEMBER_ID = VM.MEMBER_ID
    WHERE VDC.COLLECTION_DATE BETWEEN :P40_DATE_FROM AND  :P40_DATE_TO
      AND VM.ACCOUNT_NO = :P40_ACCOUNT_NO;

    vDATASET := vDATASET||' <input id="b_print" type="button" class="t-Button01_526" style="float:right;"  onclick="printdiv(''div_print'');" value=" Print " onload="openWindow.print()">';
    vDATASET := vDATASET||' <input id="b_print" type="button" class="t-Button02_526" style="float:right;"  onClick="tableToExcel(''div_print'');" value=" Excel ">'; 
    --vDATA_OUTPUT := vDATA_OUTPUT||'<input id="b_exit" type="button" class="t-Button01_526" style="float:right;"  onClick="onClick="window.location.href=''f?p=&APP_ID.:9:&APP_SESSION.''" value="Create New Invoice">';
     vDATASET := vDATASET||'<div id="div_print">';  

vDATASET := vDATASET||' <body>';



vDATASET := vDATASET||'      
     <div class="company-info"> 
            <h2 class="com-title">Bhai Bhai Shramjibi Cooperative Society Ltd.</h2> 
            <p style="font-weight:bold;">  Address: 24/2 Maniknagar,Mugda, Wari, Dhaka-1203</p>
            <p> Statement Report</p>
    </div>';

       FOR USER_INFO IN (SELECT MEMBER_NAME, ACCOUNT_NO, JOINING_DATE, MEMBER_ADDRESS, BLOCK_CODE
                           FROM VV_MEMBER
                           WHERE ACCOUNT_NO = :P40_ACCOUNT_NO
                         ) LOOP
 
                         
vDATASET := vDATASET||'       
    <div class="user">
        <div class="user-info"> 
            <h3>Joining Date: '||TO_CHAR(USER_INFO.JOINING_DATE,'DD-MON-RRRR')||'</h3>
            <h3>Address: '||USER_INFO.MEMBER_ADDRESS||'</h3>
            <h4>Block: '||USER_INFO.BLOCK_CODE||'</h4>
        </div>
  
         <div class="user-info2"> 
            <h3>Account Name: '||USER_INFO.MEMBER_NAME||'</h3>
            <h3>Acconut No: '||USER_INFO.ACCOUNT_NO||'</h3> 
            <h4>Statement Period: '||:P40_DATE_FROM||' to '||:P40_DATE_TO||'</h4>
            </div>
        </div>';

    END LOOP;

    FOR BAL IN (SELECT SUM(VDC.COLLECTION_AMOUT) COLLECTION_AMOUT, MAX(OPENING.OPEN_BAL) OPEN_BAL, MAX(NVL(EXIST_BAL.NOW_BAL,BAL.BALANCE)) NOW_BAL, MAX(WITHDRAW_BAL.WITHDRAW_AMT) WITHDRAW_AMT--, MAX(BAL.BALANCE) BALANCE
                       INTO vCOL_AMT, vOPEN_BAL, vNOW_BAL, vWITH_AMT
                FROM VV_DAILY_COLLECTION VDC
                LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VDC.MEMBER_ID
                LEFT JOIN (
                    -- BEFORE FROM DATE COLLECTED AMOUNT
                    SELECT VDC.MEMBER_ID, SUM(VDC.COLLECTION_AMOUT) OPEN_BAL
                    FROM VV_DAILY_COLLECTION VDC
                    LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VDC.MEMBER_ID 
                    WHERE VDC.COLLECTION_DATE < :P40_DATE_FROM
                     AND VM.ACCOUNT_NO = :P40_ACCOUNT_NO
                    GROUP BY VDC.MEMBER_ID
                ) OPENING ON OPENING.MEMBER_ID = VDC.MEMBER_ID
                LEFT JOIN (
                    --- AFTER TO DATE COLLECTED AMOUNT
                    SELECT VDC.MEMBER_ID, SUM(VDC.COLLECTION_AMOUT) NOW_BAL
                    FROM VV_DAILY_COLLECTION VDC
                    LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VDC.MEMBER_ID 
                    WHERE VDC.COLLECTION_DATE > :P40_DATE_TO
                     AND VM.ACCOUNT_NO = :P40_ACCOUNT_NO
                    GROUP BY VDC.MEMBER_ID
                ) EXIST_BAL ON EXIST_BAL.MEMBER_ID = VDC.MEMBER_ID
                LEFT JOIN 
                            (
                                ----- REMAIN BALANCE COLLECTED AMOUNT
                                SELECT (A.COL_AMT - A.WITHDRAW_AMT) BALANCE , A.MEMBER_ID
                                FROM 
                                    (
                                        SELECT MAX(NVL(COLL.COL_AMT,0)) COL_AMT, SUM(NVL(WITHDRAW_AMT,0)) WITHDRAW_AMT, COLL.MEMBER_ID
                                        FROM 
                                            (
                                                SELECT SUM(NVL(VDC.COLLECTION_AMOUT,0)) COL_AMT, VDC.MEMBER_ID
                                                FROM VV_DAILY_COLLECTION VDC
                                                 LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VDC.MEMBER_ID
                                                WHERE VM.ACCOUNT_NO = :P40_ACCOUNT_NO 
                                                GROUP BY VDC.MEMBER_ID
                                            ) COLL
                                        LEFT JOIN VV_COLL_WITHDRAW VCW ON VCW.MEMBER_ID =  COLL.MEMBER_ID
                                        GROUP BY COLL.MEMBER_ID
                                    ) A 
                            ) BAL ON BAL.MEMBER_ID = VDC.MEMBER_ID
                 LEFT JOIN 
                            (
                                SELECT SUM(VCW.WITHDRAW_AMT) WITHDRAW_AMT, VCW.MEMBER_ID
                                 FROM VV_COLL_WITHDRAW VCW
                                 LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VCW.MEMBER_ID
                                 WHERE VM.ACCOUNT_NO = :P40_ACCOUNT_NO 
                                   AND VCW.WITHDRAW_DATE BETWEEN :P40_DATE_FROM AND  :P40_DATE_TO
                                 GROUP BY VCW.MEMBER_ID 
                            ) WITHDRAW_BAL ON WITHDRAW_BAL.MEMBER_ID = VM.MEMBER_ID
                WHERE VDC.COLLECTION_DATE BETWEEN :P40_DATE_FROM AND  :P40_DATE_TO
                  AND VM.ACCOUNT_NO = :P40_ACCOUNT_NO
                ) LOOP

vDATASET := vDATASET||'      
     <div class="account-summary"> 
       <h2 class="summary-title">Account Summary</h2>
       <p>Balance In '||:P40_DATE_FROM||': '||BAL.OPEN_BAL||'</p>
       <p>Total Money In :'||BAL.COLLECTION_AMOUT||'</p>
       <p>Total Money Out :'||BAL.WITHDRAW_AMT||'</p>
       <p>Balance In '||:P40_DATE_TO||': '||BAL.NOW_BAL||'</p>
    </div>';

    END LOOP;

vDATASET := vDATASET||'     
     <table>';

        

      vDATASET := vDATASET||'      
      <thead>
             <tr>
                 <th>Date</th>
                 <th>Description</th> 
                 <th>Deposit</th>
                 <th>Withdraw</th>
                 <th>Balance</th>
             </tr>
         </thead>
         <tbody>';

        vDATASET := vDATASET||'
             <tr>
                 <td colspan="4" style="text-align:left; border-right: none;">Previous Balance</td>
                 <td style="text-align:right; border-left: none;">'||vOPEN_BAL||'</td>
             </tr>';

        FOR C1 IN (
                SELECT DATA.*, OPEN_BAL+BALANCE  MAIN_BAL
                FROM 
                (
                   SELECT ROWNUM, DT.*, SUM(DT.COLLECTION_AMOUNT -  NVL (DT.WITHDRAW_AMT, 0)) OVER (ORDER BY ROWNUM)   AS BALANCE 
                     FROM (
                      SELECT A.ACCOUNT_NO,
                             CASE
                                 WHEN A.COLLECTION_DATE IS NULL THEN A.WITHDRAW_DATE
                                 ELSE A.COLLECTION_DATE
                             END COLLECTION_DATE,
                             A.COLLECTION_AMOUNT,
                             A.WITHDRAW_DATE,
                             A.WITHDRAW_AMT,
                             NVL (A.COLLECTION_AMOUNT, 0) - NVL (A.WITHDRAW_AMT, 0) BAL  
                        FROM (  SELECT VM.ACCOUNT_NO,
                                       VDC.COLLECTION_DATE,
                                       SUM (NVL (VDC.COLLECTION_AMOUT, 0))     COLLECTION_AMOUNT,
                                       NULL WITHDRAW_DATE,
                                       0 WITHDRAW_AMT
                                  FROM VV_MEMBER VM
                                  LEFT JOIN VV_DAILY_COLLECTION VDC ON VDC.MEMBER_ID = VM.MEMBER_ID
                                 WHERE VM.COLLECTED_AMOUNT > 0
                              GROUP BY VM.ACCOUNT_NO, VDC.COLLECTION_DATE
                                HAVING VM.ACCOUNT_NO = :P40_ACCOUNT_NO 
                                   AND VDC.COLLECTION_DATE BETWEEN :P40_DATE_FROM AND  :P40_DATE_TO
                              UNION ALL
                                SELECT VM.ACCOUNT_NO,
                                       NULL COLLECTION_DATE,
                                       0 COLLECTION_AMOUNT,
                                       VCW.WITHDRAW_DATE,
                                       SUM (NVL (VCW.WITHDRAW_AMT, 0))     WITHDRAW_AMT
                                  FROM VV_MEMBER VM
                                  LEFT JOIN VV_COLL_WITHDRAW VCW ON VCW.MEMBER_ID = VM.MEMBER_ID
                                 WHERE VCW.WITHDRAW_AMT > 0
                              GROUP BY VCW.WITHDRAW_DATE, VM.ACCOUNT_NO
                                HAVING VM.ACCOUNT_NO = :P40_ACCOUNT_NO 
                                   AND VCW.WITHDRAW_DATE  BETWEEN :P40_DATE_FROM AND  :P40_DATE_TO 
                              ORDER BY COLLECTION_DATE, WITHDRAW_DATE
                              ) A
                    ORDER BY COLLECTION_DATE
                  ) DT
                ) DATA 
            LEFT JOIN (
                SELECT VM.ACCOUNT_NO, SUM(VDC.COLLECTION_AMOUT) OPEN_BAL
                FROM VV_DAILY_COLLECTION VDC
                LEFT JOIN VV_MEMBER VM ON VM.MEMBER_ID = VDC.MEMBER_ID 
                WHERE VDC.COLLECTION_DATE < :P40_DATE_FROM
                 AND VM.ACCOUNT_NO = :P40_ACCOUNT_NO
                GROUP BY VM.ACCOUNT_NO
            ) OPENING ON OPENING.ACCOUNT_NO = DATA.ACCOUNT_NO
    ) LOOP

vDATASET := vDATASET||' 
             <tr>
                 <td>'||TO_CHAR(C1.COLLECTION_DATE,'DD-MON-RRRR')||'</td>
                 <td>Transaction '||vSLNO||'</td> 
                 <td>'||C1.COLLECTION_AMOUNT||'</td>
                 <td>'||C1.WITHDRAW_AMT||'</td>
                 <td class="balance">'||C1.MAIN_BAL||'</td>
             </tr>
             
         </tbody>';

    END LOOP;
  vDATASET := vDATASET||'
    <tfoot>
            <tr>
                <td colspan="2"> Ending Balance </td>
                <td colspan="4" class="total-balacne"> '||vNOW_BAL||' </td>
             </tr>
         </tfoot>
     </table>

     <div class="footer">
        <p style="border-top: 1px solid #000;margin-top: 30px;">Field Officer </p>
        <p style="border-top: 1px solid #000;margin-top: 30px;">Account </p>
        <p style="border-top: 1px solid #000;margin-top: 30px;">Manager </p>
     </div>
';

RETURN vDATASET;

END;
*/



