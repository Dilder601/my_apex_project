CREATE TABLE "ADMINISTRATION_SBU" 
   (	"ID" NUMBER(10,0) NOT NULL ENABLE, 
	"PARENT" NUMBER(10,0), 
	"LVL" NUMBER(1,0), 
	"SBU_TYPE" NUMBER(10,0), 
	"SBU_KEY" VARCHAR2(64), 
	"SBU_CODE" VARCHAR2(20), 
	"SBU_NAME" VARCHAR2(100), 
	"SHORT_CODE" VARCHAR2(20), 
	"SBU_ADDRESS" VARCHAR2(200), 
	"SBU_ADDRESS2" VARCHAR2(200), 
	"SBU_PHONE" VARCHAR2(50), 
	"SBU_EMAIL" VARCHAR2(50), 
	"SBU_WEB_URL" VARCHAR2(200), 
	"SBU_LOGO" NUMBER(10,0), 
	"SBU_START_DATE" DATE, 
	"SBU_REG_DATE" DATE, 
	"SBU_ABOUT" VARCHAR2(1000), 
	"SBU_MISSION" VARCHAR2(1000), 
	"SBU_VISION" VARCHAR2(1000), 
	"SBU_SLOGAN" VARCHAR2(300), 
	"NO_OF_SIS_CONCERN" NUMBER(10,0), 
	"NO_OF_ACTIVE_USER" NUMBER(10,0), 
	"SBU_CHIEF_AUTHORITY" NUMBER(10,0), 
	"SBU_KEY_CONTACT" NUMBER(10,0), 
	"SBU_ADMINISTRATOR" NUMBER(10,0), 
	"HAVE_OWN_COA" VARCHAR2(1) DEFAULT 'N', 
	"SBU_COA_ID" NUMBER(10,0), 
	"COA_ROLL_UP" VARCHAR2(1) DEFAULT 'N', 
	"SBU_RC_ID" NUMBER(10,0), 
	"SBU_REPORT_CONFIG_ID" NUMBER(10,0), 
	"DEFAULT_FILE_PATH" VARCHAR2(200), 
	"OLD_CODE" VARCHAR2(30), 
	"EMP_ID_PRIFIX" VARCHAR2(20), 
	"STATUS" VARCHAR2(10) DEFAULT '1', 
	"CREATED_BY" VARCHAR2(100), 
	"CREATED_AT" TIMESTAMP (6) DEFAULT SYSDATE, 
	"UPDATED_BY" VARCHAR2(100), 
	"UPDATED_AT" TIMESTAMP (6)
   ) ;
/

  CREATE TABLE "BUYER" 
   (	"BUYER_ID" NUMBER(10,0), 
	"BUYER_NAME" VARCHAR2(30), 
	"ITEM_NAME" VARCHAR2(30), 
	 UNIQUE ("BUYER_ID")
  USING INDEX  ENABLE
   ) ;
/

  CREATE OR REPLACE EDITIONABLE TRIGGER "BUYER_ID" 
before insert 
on BUYER
for each row
begin
:new.BUYER_ID:=BUYER_seq.nextval;
end;

/

  CREATE TABLE "CAPACITY_STUDY" 
   (	"CAPA_ID" NUMBER(10,0), 
	"STYLE_NAME" VARCHAR2(10), 
	"PROCESS_NAME" VARCHAR2(40)
   ) ;
/

  CREATE TABLE "CUSTOMERS" 
   (	"CUSTOMER_ID" NUMBER(10,0), 
	"CUST_NAME" VARCHAR2(30) NOT NULL ENABLE, 
	"CUST_PHONE" VARCHAR2(30), 
	"CUST_EMAIL" VARCHAR2(30), 
	"LOCATION" VARCHAR2(30), 
	"GENDER" VARCHAR2(30), 
	"CUSTOMER_IMAGE" BLOB, 
	 CONSTRAINT "PK_CUST_ID" PRIMARY KEY ("CUSTOMER_ID")
  USING INDEX  ENABLE, 
	 CONSTRAINT "UK_CUST_PHONE" UNIQUE ("CUST_PHONE")
  USING INDEX  ENABLE, 
	 CONSTRAINT "UK_CUST_EMAIL" UNIQUE ("CUST_EMAIL")
  USING INDEX  ENABLE
   ) ;
/

  CREATE OR REPLACE EDITIONABLE TRIGGER "TRG_CUST_ID" 
before insert 
on customers
for each row
begin
:new.customer_id:=cust_seq.nextval;
end;

/

  CREATE TABLE "DEPARTMENT" 
   (	"DEPT_ID" NUMBER(10,0), 
	"DEPT_NAME" VARCHAR2(20)
   ) ;
/


  CREATE TABLE "EMPLOYEE" 
   (	"EMP_ID" NUMBER(10,0), 
	"EMP_NAME" VARCHAR2(20)
   ) ;
/

  CREATE OR REPLACE EDITIONABLE TRIGGER "EMP_seq" 
before insert 
on EMPLOYEE
for each row
begin
:new.EMP_ID:=EMP_seq.nextval;
end;

/

CREATE TABLE "FINISHING" 
   (	"FIN_ID" NUMBER(10,0), 
	"BUYER_NAME" VARCHAR2(30), 
	"ITEM" VARCHAR2(20), 
	"ENTRY_DATE" DATE DEFAULT SYSDATE, 
	"TOTAL_SEND" NUMBER(10,0), 
	"TOTAL_RECEIVE" NUMBER(10,0), 
	"TOTAL_REJECT" NUMBER(10,0), 
	"STYLE_ID" NUMBER, 
	"STATUS" NUMBER DEFAULT 1, 
	"FLOOR" NUMBER, 
	"TOTAL_RECEIVE_FROM_SEWING" NUMBER, 
	"TOTAL_BALANCE" NUMBER, 
	"LINE_NO" NUMBER, 
	"RESPONSIBLE_PERSON" VARCHAR2(30), 
	"RECEIVED_DATE" DATE, 
	 UNIQUE ("BUYER_NAME") DISABLE, 
	 CONSTRAINT "FINISHING_UNIQUE" UNIQUE ("STYLE_ID") DISABLE
   ) ;

  CREATE OR REPLACE EDITIONABLE TRIGGER "FINISH_TO_STK" 
    AFTER INSERT OR UPDATE OR DELETE
    ON FINISHING
    FOR EACH ROW
DECLARE
    vStyle_Exist   NUMBER := 0;
--vSTK   NUMBER;
BEGIN
    SELECT COUNT (STYLE_ID)
      INTO vStyle_Exist
      FROM STYLE_STK
     WHERE STYLE_ID = :NEW.STYLE_ID;
     
    IF INSERTING THEN
        IF vStyle_Exist = 0 THEN
            INSERT INTO STYLE_STK  (STYLE_ID, TOTAL_SEND, TOTAL_RECEIVE, TOTAL_REJECT, 
                                    FLOOR, TOTAL_RECEIVE_FROM_SEWING, TOTAL_BALANCE, LINE_NO)
                 VALUES (:NEW.STYLE_ID, :NEW.TOTAL_SEND, :NEW.TOTAL_RECEIVE, :NEW.TOTAL_REJECT,
                         :NEW.FLOOR, :NEW.TOTAL_RECEIVE_FROM_SEWING, :NEW.TOTAL_BALANCE, :NEW.LINE_NO);
                 
        ELSIF vStyle_Exist > 0  THEN
            UPDATE STYLE_STK
               SET TOTAL_SEND =  NVL (TOTAL_SEND, 0) + NVL (:NEW.TOTAL_SEND, 0),
                   TOTAL_RECEIVE =  NVL (TOTAL_RECEIVE, 0) + NVL (:NEW.TOTAL_RECEIVE, 0),
                   TOTAL_REJECT = NVL (TOTAL_REJECT, 0) + NVL (:NEW.TOTAL_REJECT, 0),
                   TOTAL_RECEIVE_FROM_SEWING = NVL (TOTAL_RECEIVE_FROM_SEWING, 0) + NVL (:NEW.TOTAL_RECEIVE_FROM_SEWING, 0),
                   TOTAL_BALANCE = NVL (TOTAL_BALANCE, 0) + NVL (:NEW.TOTAL_BALANCE, 0)
             WHERE STYLE_ID = :NEW.STYLE_ID;
        END IF;
    ELSIF UPDATING THEN
        UPDATE STYLE_STK
           SET TOTAL_SEND = NVL (TOTAL_SEND, 0) + (NVL (:NEW.TOTAL_SEND, 0) - NVL (:OLD.TOTAL_SEND, 0)),
               TOTAL_RECEIVE = NVL (TOTAL_RECEIVE, 0) + (NVL (:NEW.TOTAL_RECEIVE, 0) - NVL (:OLD.TOTAL_RECEIVE, 0)),
               TOTAL_REJECT = NVL (TOTAL_REJECT, 0) + (NVL (:NEW.TOTAL_REJECT, 0) - NVL (:OLD.TOTAL_REJECT, 0)),
               TOTAL_RECEIVE_FROM_SEWING = NVL(TOTAL_RECEIVE_FROM_SEWING, 0) + (NVL (:NEW.TOTAL_RECEIVE_FROM_SEWING, 0) - NVL(:OLD.TOTAL_RECEIVE_FROM_SEWING, 0)),
               TOTAL_BALANCE = NVL(TOTAL_BALANCE, 0) + (NVL (:NEW.TOTAL_BALANCE, 0) - NVL(:OLD.TOTAL_BALANCE, 0))
         WHERE STYLE_ID = :NEW.STYLE_ID;
    ELSIF DELETING THEN
        UPDATE STYLE_STK
           SET TOTAL_SEND = NVL (TOTAL_SEND, 0) - NVL (:OLD.TOTAL_SEND, 0),
               TOTAL_RECEIVE = NVL (TOTAL_RECEIVE, 0) - NVL (:OLD.TOTAL_RECEIVE, 0),
               TOTAL_REJECT = NVL (TOTAL_REJECT, 0) - NVL (:OLD.TOTAL_REJECT, 0),
               TOTAL_RECEIVE_FROM_SEWING = NVL (TOTAL_RECEIVE_FROM_SEWING, 0) - NVL (:OLD.TOTAL_RECEIVE_FROM_SEWING, 0),
               TOTAL_BALANCE =  NVL (TOTAL_BALANCE, 0) - NVL (:OLD.TOTAL_BALANCE, 0)
         WHERE STYLE_ID = :NEW.STYLE_ID;
    END IF;
    
END FINISH_TO_STK;

/

ALTER TRIGGER "FINISH_TO_STK" ENABLE;
  CREATE OR REPLACE  TRIGGER "FIN_ID" 
before insert 
on FINISHING
for each row
begin
:new.FIN_ID:=Fin_seq.nextval;
end;

/

  CREATE TABLE "FLOOR" 
   (	"FLOOR_ID" NUMBER(10,0), 
	"FLOOR_NAME" VARCHAR2(30)
   ) ;
/

  CREATE TABLE "HT_USER_INFO" 
   (	"USER_NO" NUMBER, 
	"USER_ID" VARCHAR2(30), 
	"USER_TYPE" VARCHAR2(50), 
	"USER_NAME" VARCHAR2(50), 
	"USER_KEY" VARCHAR2(50), 
	"USER_EMAIL" VARCHAR2(50), 
	"USER_MOBILE" VARCHAR2(50), 
	"IS_EXPIRED" NUMBER(1,0) DEFAULT 0, 
	"REMARKS" VARCHAR2(1000), 
	"STATUS" NUMBER(1,0) DEFAULT 1, 
	"COMPANY_NO" NUMBER, 
	"CREATEED_DT" DATE DEFAULT SYSDATE, 
	"CREATED_BY" VARCHAR2(30), 
	"UPDATED_DT" DATE, 
	"UPDATED_BY" VARCHAR2(30), 
	"IS_LOCK" VARCHAR2(20), 
	"IS_CHANGED" NUMBER, 
	"IS_COUNTER" VARCHAR2(20), 
	"IS_FAULT" VARCHAR2(20), 
	"LAST_LOGIN_DATE" DATE, 
	 CONSTRAINT "HT_USER_INFO_PK" PRIMARY KEY ("USER_NO")
  USING INDEX  ENABLE
   ) ;
/

  CREATE OR REPLACE  TRIGGER "USER_ID" 
before insert 
on HT_USER_INFO
for each row
begin
:new.USER_NO:=HT_USER_IN.nextval;
end;

/


  CREATE TABLE "HT_USER_INFO_LOGS" 
   (	"LOGID" NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"USERNAME" VARCHAR2(100), 
	"USER_NO" NUMBER, 
	"LOG_DT" DATE DEFAULT sysdate, 
	"CREATED_DT" DATE, 
	"CREATED_BY" VARCHAR2(40), 
	"REMARKS" VARCHAR2(30), 
	"LOGIN_TIME" DATE, 
	"USER_NAME" VARCHAR2(40), 
	"APP_SESSION" VARCHAR2(100)
   ) ;
/


  CREATE TABLE "PRODUCT" 
   (	"PRODUCT_ID" NUMBER(8,0), 
	"PRODUCT_NAME" VARCHAR2(30) NOT NULL ENABLE, 
	"PRODUCT_MODEL" VARCHAR2(30) NOT NULL ENABLE, 
	"PURCHASE_PRICE" NUMBER(10,0) NOT NULL ENABLE, 
	"PRODUCT_AVAILABLE" VARCHAR2(30), 
	"PRODUCT_IMAGE" BLOB, 
	"CATAGORY_ID" NUMBER(10,0), 
	"PRODUCT_DESCRIPTION" VARCHAR2(200), 
	"SELLING_PRICE" NUMBER, 
	 CONSTRAINT "PK_PRODUCT_ID" PRIMARY KEY ("PRODUCT_ID")
  USING INDEX  ENABLE, 
	 CONSTRAINT "pro_name_UK" UNIQUE ("PRODUCT_NAME")
  USING INDEX  ENABLE, 
	 CONSTRAINT "pro_model_UK" UNIQUE ("PRODUCT_MODEL")
  USING INDEX  ENABLE
   ) ;
/


  CREATE OR REPLACE  TRIGGER "TRG_PRO_ID" 
before insert 
on PRODUCT
for each row
begin
:new.PRODUCT_ID:=pro_id_seq.nextval;
end;

/

  CREATE TABLE "PRODUCT_CATEGORY" 
   (	"CATEGORY_ID" NUMBER(10,0), 
	"CATEGORY_NAME" VARCHAR2(30) NOT NULL ENABLE, 
	"CATEGORY_DESCRIPTION" VARCHAR2(100), 
	 CONSTRAINT "PK_CAT_ID" PRIMARY KEY ("CATEGORY_ID")
  USING INDEX  ENABLE, 
	 CONSTRAINT "CAT_ID_UK" UNIQUE ("CATEGORY_NAME")
  USING INDEX  ENABLE
   ) ;
/

  CREATE OR REPLACE  TRIGGER "TRG_CAT_ID" 
before insert 
on PRODUCT_CATEGORY
for each row
begin
:new.CATEGORY_ID:=cat_id_seq.nextval;
end;

/

CREATE TABLE "QC_TAB" 
   (	"QC_DATE" DATE, 
	"LINE_NUMBER" NUMBER, 
	"DOWN_STS" NUMBER, 
	"UNEVEN_SHAP" NUMBER, 
	"BROKEN_STS" NUMBER, 
	"DIRTY_MARK" NUMBER, 
	"OIL_STAIN" NUMBER, 
	"HIKING" NUMBER, 
	"IMPORPER_TUCK" NUMBER, 
	"NEEDLE_MARK_HOLE" NUMBER, 
	"OPEN_SEAM" NUMBER, 
	"SKIP_STS" NUMBER, 
	"PLEAT" NUMBER, 
	"SLV_SHOULDER_UPDOWN" NUMBER, 
	"PUCKERING" NUMBER, 
	"RAWEDGE" NUMBER, 
	"SHADING" NUMBER, 
	"UNCUT_THREAD" NUMBER, 
	"OTHERS" NUMBER, 
	"TOTAL_ALTER" NUMBER, 
	"TOTAL_OUTPUT" NUMBER, 
	"DHU" NUMBER, 
	"START_HOUR" TIMESTAMP (6) WITH TIME ZONE, 
	"END_HOUR" TIMESTAMP (6) WITH TIME ZONE, 
	"ID" NUMBER, 
	"SBU_ID" NUMBER, 
	"USER_NAME" VARCHAR2(100), 
	"STATUS" NUMBER, 
	"CREATED_AT" DATE, 
	"CREATED_BY" VARCHAR2(100), 
	"UPDATE_AT" DATE, 
	"UPDATE_BY" VARCHAR2(100), 
	"LABEL_ALTER" NUMBER
   ) ;
/

 CREATE TABLE "SALES_ORDER" 
   (	"ORDER_ID" NUMBER(10,0), 
	"ORDER_DATE" DATE, 
	"ORDER_TYPE" VARCHAR2(30), 
	"ORDER_STATUS" VARCHAR2(30), 
	"CUSTOMER_ID" NUMBER(10,0), 
	"ORDER_TOTAL" NUMBER, 
	"SALES_BY" VARCHAR2(40), 
	"CUSTOMER_NAME" VARCHAR2(60), 
	"USER_NAME" VARCHAR2(40) DEFAULT SYS_CONTEXT('APEX$SESSION','APP_USER'), 
	"TOTAL_BILL" NUMBER, 
	"VAT" NUMBER, 
	"DISCOUNT" NUMBER, 
	"PAYMENT" NUMBER, 
	"DUE" NUMBER, 
	"CREATED_ON" DATE DEFAULT SYSDATE, 
	"CUSTOMER_PHONE" VARCHAR2(20), 
	"GIVEN" NUMBER, 
	"CHANGE" NUMBER, 
	 CONSTRAINT "PK_ORD_ID" PRIMARY KEY ("ORDER_ID")
  USING INDEX  ENABLE
   ) ;
/

 CREATE TABLE "SALES_ORDER_ITEMS" 
   (	"ORDER_ID" NUMBER(10,0), 
	"PRODUCT_ID" NUMBER(10,0), 
	"PRODUCT_NAME" VARCHAR2(30), 
	"PRO_MODEL" VARCHAR2(30), 
	"PRO_PRICE" NUMBER(30,0), 
	"PRO_QTY" NUMBER(30,0), 
	"TAX" NUMBER(10,0), 
	"DISCOUNT" NUMBER(10,0), 
	"TOTAL" NUMBER, 
	"PAYMENT_TYPE" VARCHAR2(60), 
	"PURCHASE_PRICE" NUMBER, 
	"SELLING_PRICE" NUMBER, 
	"VAT" NUMBER, 
	"VAT_AMOUNT" NUMBER, 
	"CREATED_ON" DATE, 
	"SALES_BY" VARCHAR2(100), 
	"SL" NUMBER, 
	 CONSTRAINT "SALE_ORDER_ITEMS_UK1" UNIQUE ("PRODUCT_ID", "ORDER_ID") DISABLE
   ) ;
/


  CREATE OR REPLACE EDITIONABLE TRIGGER "Order_TOTAL" 
  after insert or update or delete on SALES_ORDER_ITEMS
begin
  -- Update the Order Total when any order item is changed
  update SALES_ORDER set ORDER_TOTAL =
  (select sum(PRO_PRICE*PRO_QTY) from SALES_ORDER_ITEMS
    where SALES_ORDER_ITEMS.ORDER_ID = SALES_ORDER.ORDER_ID);
end;

/

CREATE TABLE "STYLE_SETUP" 
   (	"ID" NUMBER, 
	"STYLE_NAME" VARCHAR2(80), 
	"STYLE_DESCRIPTION" VARCHAR2(80), 
	"STATUS" NUMBER DEFAULT 1, 
	"SORT_ORDER" NUMBER, 
	"CREATED_BY" VARCHAR2(200), 
	"CREATED_AT" DATE, 
	"UPDATED_BY" VARCHAR2(200), 
	"UPDATED_AT" DATE, 
	"BUYER_ID" NUMBER, 
	 PRIMARY KEY ("ID")
  USING INDEX  ENABLE
   ) ;
/


  CREATE OR REPLACE  TRIGGER "TRG_STYLE_SETUP" 
BEFORE UPDATE OR INSERT OR DELETE
ON STYLE_SETUP
FOR EACH ROW
BEGIN
	IF INSERTING THEN
		IF(:NEW.ID IS NULL) THEN
			:NEW.ID := STYLE_SETUP_SEQ.NEXTVAL;
		END IF;
		 :NEW.CREATED_BY :=v('APP_USER');
		 :NEW.CREATED_AT := SYSDATE;
	ELSIF UPDATING THEN
		:NEW.UPDATED_BY := v('APP_USER');
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END TRG_STYLE_SETUP;

/

CREATE TABLE "STYLE_STK" 
   (	"ID" NUMBER, 
	"STYLE_ID" NUMBER, 
	"TOTAL_SEND" NUMBER, 
	"TOTAL_RECEIVE" NUMBER, 
	"TOTAL_REJECT" NUMBER, 
	"STATUS" NUMBER DEFAULT 1, 
	"SORT_ORDER" NUMBER, 
	"CREATED_BY" VARCHAR2(200), 
	"CREATED_AT" DATE, 
	"UPDATED_BY" VARCHAR2(200), 
	"UPDATED_AT" DATE, 
	"FLOOR" NUMBER, 
	"LINE_NO" NUMBER, 
	"TOTAL_BALANCE" NUMBER, 
	"TOTAL_RECEIVE_FROM_SEWING" NUMBER
   ) ;
/

  ALTER TABLE "STYLE_STK" ADD FOREIGN KEY ("STYLE_ID")
	  REFERENCES "STYLE_SETUP" ("ID") ENABLE;

  CREATE OR REPLACE  TRIGGER "TRG_STYLE_STK" 
BEFORE UPDATE OR INSERT OR DELETE
ON STYLE_STK
FOR EACH ROW
BEGIN
	IF INSERTING THEN
		IF(:NEW.ID IS NULL) THEN
			:NEW.ID := STYLE_STK_SEQ.NEXTVAL;
		END IF;
		 :NEW.CREATED_BY :=v('APP_USER');
		 :NEW.CREATED_AT := SYSDATE;
	ELSIF UPDATING THEN
		:NEW.UPDATED_BY := v('APP_USER');
		:NEW.UPDATED_AT := SYSDATE;
	END IF;
END TRG_STYLE_STK;

/

create or replace TYPE GET_MAX_TAB AS TABLE OF GET_MAX
/

create or replace TYPE GET_MAX AS OBJECT (ID NUMBER, COLNAME VARCHAR2(100), MAXVAL NUMBER)
/



create or replace FUNCTION GET_COL_MAX_TAB
RETURN GET_MAX_TAB
PIPELINED
AS
BEGIN

    FOR I IN (
                SELECT ADD_SUMM.LINE_NUMBER, DOWN_STS, UNEVEN_SHAP, BROKEN_STS, DIRTY_MARK, OIL_STAIN, HIKING, IMPORPER_TUCK, NEEDLE_MARK_HOLE,
                        OPEN_SEAM, SKIP_STS, PLEAT, SLV_SHOULDER_UPDOWN, PUCKERING, RAWEDGE, SHADING,  LABEL_ALTER -- UNCUT_THREAD
                    FROM 
                    (
                        SELECT  LINE_NUMBER,  SUM(NVL(DOWN_STS,0)) DOWN_STS, SUM(NVL(UNEVEN_SHAP,0)) UNEVEN_SHAP, SUM(NVL(BROKEN_STS,0)) BROKEN_STS, 
                                SUM(NVL(DIRTY_MARK,0)) DIRTY_MARK, SUM(NVL(OIL_STAIN,0)) OIL_STAIN , SUM(NVL(HIKING,0)) HIKING,  SUM(NVL(IMPORPER_TUCK,0)) IMPORPER_TUCK, 
                                SUM(NVL(NEEDLE_MARK_HOLE,0)) NEEDLE_MARK_HOLE,  SUM(NVL(OPEN_SEAM,0)) OPEN_SEAM, SUM(NVL(SKIP_STS,0)) SKIP_STS, SUM(NVL(PLEAT,0)) PLEAT, 
                                SUM(NVL(SLV_SHOULDER_UPDOWN,0)) SLV_SHOULDER_UPDOWN, SUM(NVL(PUCKERING,0)) PUCKERING, SUM(NVL(RAWEDGE,0)) RAWEDGE,  SUM(NVL(SHADING,0)) SHADING, 
                                SUM(NVL(UNCUT_THREAD,0)) UNCUT_THREAD, SUM(NVL(OTHERS,0)) OTHERS, SUM(0) LABEL_ALTER
                        FROM QC_TAB
                        GROUP BY LINE_NUMBER
                        ORDER BY LINE_NUMBER ASC
                    ) ADD_SUMM
    ) LOOP
    
        FOR J IN (
                    SELECT COLN, VAL 
                    FROM
                    (
                    SELECT A.STR_VALUE COLN, B.STR_VALUE VAL, 
                    (SELECT MAX (TO_NUMBER (STR_VALUE)) FROM DFN_GET_STRING_SPLITTED ((SELECT SUM(LABEL_ALTER)||','||SUM(DOWN_STS)||','||SUM(UNEVEN_SHAP)||','||SUM(BROKEN_STS)||','||SUM(DIRTY_MARK)||','||SUM(OIL_STAIN)||','||SUM(HIKING)||','||SUM(IMPORPER_TUCK)||','||SUM(NEEDLE_MARK_HOLE)||','||SUM(OPEN_SEAM)||','||SUM(SKIP_STS)||','||SUM(PLEAT) 
                                                                                            ||','||SUM(SLV_SHOULDER_UPDOWN)||','||SUM(PUCKERING)||','||SUM(RAWEDGE)||','||SUM(SHADING)||','||SUM(UNCUT_THREAD)||','||SUM(OTHERS)
                                                                                        FROM QC_TAB WHERE LINE_NUMBER = I.LINE_NUMBER),',')) max_val
                    FROM
                    (SELECT * FROM DFN_GET_STRING_SPLITTED ('LABEL_ALTER ,DOWN_STS,UNEVEN_SHAP,BROKEN_STS,DIRTY_MARK,OIL_STAIN,HIKING,IMPORPER_TUCK,NEEDLE_MARK_HOLE,OPEN_SEAM,SKIP_STS,PLEAT,SLV_SHOULDER_UPDOWN,PUCKERING,RAWEDGE,SHADING,UNCUT_THREAD,OTHERS',',')) A,
                    (SELECT * FROM DFN_GET_STRING_SPLITTED ((SELECT SUM(LABEL_ALTER)||','||SUM(DOWN_STS)||','||SUM(UNEVEN_SHAP)||','||SUM(BROKEN_STS)||','||SUM(DIRTY_MARK)||','||SUM(OIL_STAIN)||','||SUM(HIKING)||','||SUM(IMPORPER_TUCK)||','||SUM(NEEDLE_MARK_HOLE)||','
                                                                    ||SUM(OPEN_SEAM)||','||SUM(SKIP_STS)||','||SUM(PLEAT)||','||SUM(SLV_SHOULDER_UPDOWN)||','||SUM(PUCKERING)||','||SUM(RAWEDGE)||','||SUM(SHADING)||','||SUM(UNCUT_THREAD)||','||SUM(OTHERS)
                                                            FROM QC_TAB WHERE LINE_NUMBER = I.LINE_NUMBER),',')) B
                    WHERE A.SRL_NO = B.SRL_NO
                    ) V
                    WHERE VAL = MAX_VAL
        ) LOOP
        
            PIPE ROW (GET_MAX (I.LINE_NUMBER, J.COLN, J.VAL));
        
        END LOOP;
    
    END LOOP;

END;
/





create or replace TYPE SPLITTED_TAB AS TABLE OF SPLITTED
/

create or replace TYPE SPLITTED AS OBJECT (SRL_NO NUMBER(10), STR_VALUE VARCHAR2(2000))
/




create or replace FUNCTION DFN_GET_STRING_SPLITTED (PSTRING       VARCHAR2, PSEPARATOR    VARCHAR2)
RETURN SPLITTED_TAB
PIPELINED
IS
   VSTRING   VARCHAR2 (4000) := REPLACE (PSTRING, PSEPARATOR, '~');
BEGIN
   FOR I IN (    SELECT REGEXP_SUBSTR (VSTRING, '[^~]+', 1, LEVEL) VAL, ROWNUM RID
                   FROM DUAL
             CONNECT BY REGEXP_SUBSTR (VSTRING, '[^~]+', 1, LEVEL) IS NOT NULL)
   LOOP
      PIPE ROW (SPLITTED (I.RID, I.VAL));
   END LOOP;
EXCEPTION
   WHEN OTHERS
   THEN
      NULL;
END DFN_GET_STRING_SPLITTED;
/


